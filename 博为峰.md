博为峰学习笔记

# 一、Excel基础

## 1、学习工具

### 1.1、截图
> Quicker：单击滚轮
>
> QQ: Ctrl+Alt +A
>
> 微信：Alt +A
>
> 电脑自带：Win + Shift + S


### 1.2、Markdown笔记
​	1）joplin

​	2）typora

> 大纲、
>
> 标题（Ctrl + 123456）、
>
> 代码块（Ctrl + Shift + K）、
>
> 注释（Ctrl + Shift + Q）、
>
> 设置文件、图片保存位置、
>
> ![img](https://cdn.jsdelivr.net/gh/22o33/Pictures@master/1683429431609-268aeb63-6fc0-414c-a67e-1155c90ead6c.png)

### 1.3、思维导图
​	Xmind
![img](https://cdn.jsdelivr.net/gh/22o33/Pictures@master/1683429488304-0edf5eaf-b49d-4d2b-a224-4d2491b390d5.png)

## 2、数据获取

### 2.1、自文本.txt

​	分隔符号 --- 分隔符号（其他） --- 列数据的类型

### 2.2、自CSV
​	【数据】从文本/CSV

### 2.3、自Web
​	【数据】自网站——打勾✔，导入

## 3、数据预处理

### 3.1、一维表、二维表
​	一维：一个指标只有一列数据，主要用于数据录入

​	二维：同个指标有多列数据，主要用于对外展示

### 3.2、行列操作

#### 设置单元格格式
​	CTRL + 1

#### 保护单元格
​	选中区域/表，CTRL + 1，保护【锁定/权限设置】

#### 高级筛选
​	【数据】排序筛选
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1682663145698-5dfd7611-90f2-417e-8357-8e1c61fdf266.png)
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1682663988697-652931bb-402c-4e1c-a78e-7c35665145cf.png)

#### 规范数据
​	CTRL+ D，智能向下填充

#### 排序原理
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1682664616044-2146f06d-af28-4520-af1a-0d2e0dddc058.png)

#### 高级排序
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1682667228227-857f2b28-2619-4f45-9348-7f279d75a5ca.png)

#### 条件格式

#### 数据条
​	数值对比、增减、排行
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1682667661402-d5d8a7a5-4b0d-4731-95f1-66f950d803f2.png)

#### 图标集
​	种类划分
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1682667761042-1228535a-0d4c-4476-9232-f168698a1ce1.png)

#### 热度
​	突出重点区间
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1682668002363-04aa8e0b-28a5-48a4-9b12-fb3171a1a3cd.png)

#### 对比
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1682667906454-ea8cac84-49f1-45bf-b82d-dfeb5f8ba05f.png)

#### 迷你折线图
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1682668474510-2c1a7cd5-0c1d-41b8-a306-eae0bff2e824.png)

#### 迷你盈亏平衡图
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1682668519047-a5ea9da1-cacc-422a-83e2-f9e1d5ed83e4.png)

## 4、数据清洗

### 4.1、数据验证
下拉列表
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1682669329952-360981d2-7102-462c-a512-0284a04b592d.png)

### 4.2、合并计算
工作组：CTRL + sheet表名称，批量生成相同的格式和内容
创建随机数：randbetween
汇总
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1682670319498-cb045afc-a38b-413f-9af3-e9ef1d715694.png)
去重
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683164102340-79576528-5487-4eda-a2ca-a02283c6aec1.png)
多种计算（不推荐）

### 4.3、查找删除重复项
​	1、筛选
​	2、【数据】删除重复项
​	3、高级筛选
​	4、条件格式
​	5、【函数】countif

### 4.4、查找替换文本
​	CTRL + F

### 4.5、更改大小写
​	转大写：upper
​	转小写：lower
​	首字母大写：proper

### 4.6、删除空格、非打印字符
​	TRIM：清除单元格前后空格
​	SUBSTITUTE：清除所有空格
​	CLEAN：清除不能打印字符

### 4.7、修复数字及数字符号
​	1、ABS绝对值
​	2、设置单元格格式 CTRL + 1

### 4.8、修复日期时间
​	1、设置单元格格式yyyy-mm-dd
​	2、=TEXT（A1，"yyyy-mm-dd"）
​	3、=MID（A1，1，4）&"-"&MID（A1，5，2）&"-"&MID（A1，7，2）

### 4.9、合并拆分列
​	合并：concat、concatenate、phonetic、&
​	提取：left、right、mid
​	拆分列：【数据】分列

### 4.10、联结匹配数据
​	查找引用：vlookup、hlookup、lookup

### 4.11、常用函数
​	四舍五入：round、roundup、rounddown
​	排名函数：rank.eq
​	逻辑函数：if、and、or
​	文本函数
>长度：len
>替换：replace、substitute
>定位：find、search
>重复：rept
>提取：left、right、mid
>合并：concatenate、&
>转换：text、upper、lower

​	查找引用：vlookup、hlookup、lookup、index、match、indirect
​	时间日期：now、today、year、month、day、weekday、weeknum、datedif
​	无参数函数：today、now、row、column、rand

## 5、项目案例
需求：移动终端销售情况分析
5W2H法：为什么、做什么、何人做、何时做、何地、如何做、多少
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1682659587140-e7f535f5-c043-4f3f-ac61-db0cc18f3bb2.png)

### 梳理数据信息
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683168657127-0f22f456-0a6e-420d-8b1d-63e9a3fd710a.png)
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683168710284-d449d18b-a503-4721-97fc-db39631af5b8.png)

### 懂业务
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683168943775-5b6df85b-6e16-4406-8ead-c46d09fb1d77.png)

### 找问题
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683168963532-bcc4ad13-772f-4cb7-ba49-b52b14b37a9d.png)

### 分析方法
​	用户画像：精准定位，下单信息（年龄、性别、地址、）
​	对比分析：横向、纵向
​	漏斗分析：10000下载--8000注册--5000搜索--3000下单--2000付款--500评价
​	A/B测试：1000抽查300
​	5W2H分析：
​	多维度分析：渠道、产品、时间

#### 对比三步法

##### 比什么
​	绝对值：销售金额、阅读数、收藏数————无法得知问题严重程度
​	比例值：活跃占比、注册转化率、复购率——容易受到极端值的影响

##### 如何比
环比：与当前时间范围的上一周期对比
​	日环比、周环比、月环比
​	适用于短期且连续性数据的业务场景
同比：与当前时间范围的上一周期同一位置对比
​	年同比（某年今日）、周同比（某周周几）、多年同比（第几个五年计划的第二年）
​	适用于观察长期的数据集

##### 和谁比
​	和自己比
​		时间维度
​		不同业务线
​		往期均值
​	各行业比
​		都跌：能不能比别人跌的少
​		都涨：能不能比别人多涨点

#### 多维度分析
适用场景
​	对单一指标的构成或比例进行拆解分析
​		分栏目的播放量
​		新老用户比例
​	对业务流程进行拆解分析
​		不同渠道的浏览、购买转化率
​		不同省份的活动参与状况
​	对需要还原行为发生的场景进行拆解分析
​		打赏主播的等级、性别、频道
​		是否在WiFi、4G环境下 

## 6、数据建模
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683193366137-f5b2ffc3-dcbf-4b34-98a2-aaa2b46dadaf.png)

## 7、数据可视化
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683194168639-f4ff94d6-f334-43c0-9fab-121515cb5a06.png)
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683194253381-be94a740-ef9b-41ca-8380-895e5518e4cf.png)
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683194044912-6d8b52ca-1f67-4c4f-a79e-fa3cdda05ffa.png)

### 数据透视表
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683194421235-51e766f3-c99f-4770-b8ae-817bf81e5dd2.png)

### 切片器
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683194106329-0e88012a-b3db-4c59-8849-d70133696285.png)

### 动态数据透视表
创建名称：【公式】定义名称
引用位置：=OFFSET（销售统计表!$A$1，0，0，COUNTA（销售统计表!$A：$A），COUNTA（销售统计表!$1：$1）
创建透视表

### 多重合并
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683194995888-6d4aa22b-a1d9-4608-8e2e-aa99b2912528.png)

# 二、Power BI
​	Power Query：获取和整理
​	Power Pivot：建模和分析
​	Power View：交互式报表
​	Power Map：地图可视化
​	Power BI在线版：可视化仪表板发布分享

## 1、Power Query：获取和整理
​	Power Query是在Excel平台控制及转换数据的最佳工具（没有之一）

### 作用：
> 1、数据获取：从不同来源、不同结构、不同形式获取数据并按统一格式进行横向合并、纵向追加等
> 2、数据转换：将原始数据转换成期望的结构或格式
> 3、数据预处理：为了后续分析的需要进行数据预处理，例如：加入新列、新行、处理某些单元格值。

### 特点：
> 1、提取整合多数据源数据
> ​	(如各种关系型数据库、excel文件、txt格式以及csv格式等文本文件、web页面、Hadoop的HDFS等等）
> 2、合并多个数据源
> 3、突破Excel表格的数据限制（可快速处理几百万甚至上千万行的数据）
> 4、提供丰富的数据处理分析功能
> 5、可通过插件自带的函数公式灵活创建自定义数据处理及计算规则

### 1.1、导入数据
​	一般是gb2312和utf-8 互相转换
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683433151534-49156635-4c14-435d-810e-2f4f95bd7147.png)	
*素材4：门店销售记录*

​	导入数据——删除空行、删除前几行——提升标题——检测数据类型——全选（ctrL+a) ，删除重复项——添加辅助列，区分店铺——同理，门店二——追加汇总——修改表名称
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683433817372-23b19fde-2d52-4e04-84b6-08ebbaee00d2.png)

### 1.2、数据格式转换
*素材7：数据格式的转换.xlsx*
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683434789879-a3e76273-9d46-4e5d-aa33-a61a3b5e78eb.png)
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683435115954-eb26ac90-c460-4128-9c55-9cc91d17be51.png)

​	导入数据——【自表格/区域】
​	前后空格和非打印字符统一——【转换】修整（前后空格删除 --- trim）、清除（非打印字符（回车）删除 --- clean）
​	建议：每次导入数据之后，可以先全选表格，优先进行一次修整和清除以及删除重复项的操作
​	英文大小写统一——upper、 lower 、proper
​	英文名空格统一——复制姓、名两列，合并姓+名（分隔符”“），修改列名
​	年份统一——数字非数字互转、拆分列、left+right、添加后缀、&

### 1.3、数据格式拆分、合并、提取
*素材8：数据的拆分合并提取.xlsx*
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683435681257-e462cd5a-50ba-4006-b78b-6a7233c64511.png)

​	常规操作：导入数据——检测数据类型——全选，清除+修整，删除重复值——（身份证号码改为文本型，显示完全）
​	性别：重复身份证列——提取（索引从0 开始）——判断奇偶（【转换】编号列--奇数偶数）——改为纯文本——替换（【转换】替换值--注意大小写）
​	姓、名提取：重复姓名列——拆分列（一次靠左left--不考虑复姓）
​	尊称：重复性别列——替换（【转换】替换值--男--先生）——重复姓列——合并 姓+尊称 列
​	首要兴趣：重复兴趣爱好列——拆分列（\）或者提取两位字符数

### 1.4、删除重复项
*素材9：删除重复项.xlsx*

1）客户最大订单金额
​	客户ID升序、金额降序——检测数据类型（【转换】检测...）——客户ID去重
​	PS：检测数据类型目的是覆盖掉排序操作，因为去重时后台的运行逻辑和前台显示的并非一致

2）客户首次购买时间
​	复制 表1）（第二个复制按钮）——客户ID升序、下单日期升序——检测数据类型——客户ID去重

3）多次购买客户ID
​	客户ID——【主页】保留行——保留重复项
​	计数：1、【转换】统计信息--对非重复值进行计数
   	 	   2、ID去重后看数据条数/行数
   	 	   3、加载到excel，用count计算/透视表计算

### 1.5、删除错误
*素材10：删除错误.xlsx*

​	遇到error有错误的单元格，可以使用删除行----删除错误----强制性的删除整行内容
​	场景：1）并非整行都为空，且位置在中间，且不连续
​		   2）数据追加./批量导入时，会把各文件的标题放进去
​	处理：寻找日期列/数值列——将该列改为文本类型——将该列空值null替换为某中文——修改数据类型为日期/数值——某中文会报错——删除error

### 1.6、转置和反转
*素材11：转置和反转.xlsx*

​	**转置 -- 行列互换 --- 基于全部内容的行列互换（Transpose）**
​		PS：常将列标题降级作为第一行，再进行转置
​	**反转：倒叙的效果 ---基于行（行序变化：第一行变为最后一行）**

练习：
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683452366101-bd7d1a7f-0827-438d-859c-623e66d68f55.png)

​	方式一：按字符数拆分——转置——反转——转置——合并——完成 【灵活度更高】
> 文本要倒叙，那就需要反转，但反转是基于行的，故就要先将列数据转成行数据；接着反转后，就需要将诗歌文字进行合并，而合并是基于列的，故将反转后的行数据再转置成列数据---合并

​	方式二：按字符数拆分——直接移动列——合并 【傻瓜式操作】
​	方式三：按字符数拆分——直接合并，选择合并的顺序，从后往前选即可

### 1.7、透视、逆透视
*素材12：透视和逆透视*

​	逆透视其他列：【转换】任意列---逆透视列
​	以选中列为依据进行展开，将其他的列标题作为属性列，数据作为该属性的值列
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683452814698-17aae4cd-f93f-409c-9ce1-f0fa6576db9d.png)
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683452822610-b6adc13d-72d5-4ffb-a135-6293a7a569ab.png)
​	透视列：【转换】任意列---透视列
​	将选中列转换为列标题，值列选择相应数据区域【同时设置值的聚合方式】，剩下的另一列则作为行标题
​	PS：当值列的内容不需要任何计算操作时，尤其是文本内容【该显示什么就显示什么】——不要聚合
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683453452152-f8048310-8e0f-49e4-bb93-f0088ae1ca5f.png)
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683453473959-51aea769-8c42-49b0-bc66-98680cdf9cc4.png)

练习：
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683455874450-1b6b8b5f-4966-4831-ba63-4b3030c2a167.png)

方式一：
​	销售代表列：导入数据——删除金额列——添加索引列（辅助作为列标题）——销售代表列添加后缀\——选中索引列，进行透视列，不要聚合——合并列——拆分列（最右侧分隔\）或者用提取（末尾\）
​	金额列：【转换】分组依据——基础

方式二：
​	导入数据——提升标题，修改数据类型——销售代表列添加后缀\——【转换】分组依据——高级（聚合方式：求和）——
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683457062534-6046289b-fbcb-450b-b1b7-b77385c572b2.png)
​	修改公示区代码M函数——拆分列（最右侧分隔\）或者用提取（末尾\）
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683457195338-bc1f2446-177d-4492-abb9-76697f19709a.png)
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683457302621-1db89e7a-761e-4e35-bae9-32e2ad7ef6e8.png)
​	添加后缀\也可以在修改代码M函数里直接添加
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683457490623-190b7a3a-683a-4c1f-8211-df446296d42a.png)

### 1.8、分组依据
*素材13：分组依据.xlsx*
需求：分析每个订单编号分别是一个产品还是多个产品，并返回备注

​	1）【转换】分组依据——高级（多个分组、多个新列）
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683455108983-581418ab-f86c-4f91-a9aa-089ebac5c7f8.png)![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683454682973-c9c61424-a1a6-4b98-afd6-83a799138b9b.png)
​	2）展开计数列，选择字段，修改聚合方式（订单编号---计数全部）
​	点击table单元格的空白处，该订单的所有信息数据条都会展示到下方
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683455016398-ddb63877-5694-4d7e-a970-5a275b775421.png)
​	3）添加条件列，写好输出备注
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683455583317-bd41d001-8d8d-4f95-ab93-16aa93f63f73.png)
​	PS：query计算好后应用到excel，excel后续的操作并不会影响到query的数据变化，因为默认还是最早的源数据

### 1.9、添加列
​	索引列——从几开始，增量为0或几
​	重复列——一列一列重复
​	条件列——if...Else if...Else...
​	自定义列
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683471496557-274e2a84-6b8a-4a98-8980-1f92192fd215.png)
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683471513443-0ffab02c-3ae8-4c5e-ba6c-8f89e64e3617.png)
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683471531431-01b5d612-329e-453f-bf1a-ccbd8a6247f7.png)
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683471557037-ffd4926e-2795-4d7f-a139-00336e94da3a.png)

### 1.10、日期时间整理
​	提取：确认数据类型为日期型——【转换】日期、时间——
​	中英文时间转换：修改查询设置的区域设置（中国.简体）

### 1.11、数学运算
​	取整、四舍五入、取余、奇偶数判断：确认数据类型为数值型——【转换】编号列

### 1.12、追加查询
*素材17：追加查询.xlsx*

注意事项：
​	追加列标题名称必须完全一致
​    	注意连接方式：左、右、完全
​    	默认第一张表为追加的字段顺序

### 1.13、多文件追加汇总
1）工作簿里的多个工作表
*素材18：从Excel工作簿汇总_各省销售记录.xlsx*
​	新建空白工作簿——按住shift连选多个工作表——转换数据/加载——追加（两个/三个或更多）

2）文件夹里的多个工作簿xlsx
*素材19：从文件夹合并多个工作簿*
​	新建空白工作簿——【从文件夹】转换数据——删除其他列，留下content——添加自定义列（=Excel.Workbook([Content],true)）——
​	展开字段（）——
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683512254394-ce8ab55f-b809-4236-97f8-9eaa01100185.png)![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683512310582-47f1987a-d7c8-4735-83e0-a1ec7f811642.png)
​	检查客户省份（数据是否齐全）——全选，检测数据类型
​	PS：不建议直接使用【组合】按钮，其结果会形成多个文件夹和文件，且只显示示例打开的文件

3）文件夹里的多个CSV文件
*素材20：从文件夹合并多个CSV文件*
​	新建空白工作簿——【从文件夹】转换数据——删除其他列，留下content——单击某个Binary——
​	修改历史步骤（Content）【= 删除的其他列**{0}**[Content]】改为【= Binary.Combine(删除的其他列[Content])】——
​	回到最后一步，检查客户省份（数据是否齐全）——全选，检测数据类型——
​	清除每个表的标题——

​	**方式一：**通过删除错误，即可强制性删除标题行的内容，可以直接通过有错误的列进行或通过数据类型的转换进行手动错误的产生，一般都是文本类型转数值或日期即可产生错误
​		注意1：通过筛选可以观察数据有问题的行内容到底是什么情况，但检查过后必须将该步骤删除，否则，下次的操作是基于你筛选过后的数据表进行的
​		注意2：删除错误的操作必须选中有错误的那列内容进行，不能随便选择列删除

​	**方式二：**可以通过删除重复项进行，先将标题行下放为数据内容，利用删除重复项多余的重复标题删除后，但注意要多选字段依据【没有报错的字段】，不能只针对客户省份去重，因为客户省份下省份都是有重复值的；最后提升标题 
​		注意：一定要保证删除的重复项依据列中只有需要清除的内容是有重复值的，不能有其他的重复，否则会直接将所有有重复值的内容删除

​	**方式三：**通过文本筛选器，选择不包含【客户省份】进行筛选删除

PS：若数据源中有超过30%的报错率，该数据无法用于分析
若分析的文件有大面积的缺失值，就需要重新获取数据或想方设法填充
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683513640041-9310ef93-3b5a-4b10-a952-8d033ce721c6.png)

### 1.14、合并查询
*素材21：合并查询.xlsx*

​	需求1：基于订单表，得到每个区域不同分类的销售额情况
​		导入数据，并整理清洗——合并查询（默认省份--左外部联接）——展开匹配的区域

​	需求2：展示不同区域下不同产品分类的总金额情况
​		...——【分组依据】高级

​	需求3：将订单表与折扣表合并，求得折扣后的金额
​		基于需求1...——合并折扣表（先区域再产品分类）——展开折扣表——自定义列【=[金额]*[折扣]】
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683514310425-408f837a-10d6-43ef-a2c1-9efb3db1f0a7.png)

#### 合并查询的联接方式
​	左外部（默认）：左全部，右补充
​	右外部：右全部，左补充
​	完全外联接：左右都全部，各自全补充
​	内部：只显示完全匹配的
​	左反：左存在，右没有
​	右反：右存在，左没有

#### 练习1：中国式排名=Rank.eq
*素材23：中国式排名.xlsx*

​	并列后接上：122234567789*
​	导入数据，清洗整理——新建辅助表（复制原表，保留销售额列，降序，检测数据类型，去重）——添加排名列（从1递增）——合并查询——展开排名列
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683515533145-95f4dc7b-430f-4ee4-af8e-a822a84ffcdb.png)

​	并列后跳过：1222567899 11 12
​	导入数据，清洗整理——新建辅助表（复制原表，保留销售额列，降序，检测数据类型）——添加排名列（从1递增）——点击销售额列，进行去重——合并查询——展开排名列
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683515893965-d7d50d7a-7a91-46aa-8826-634cd822b740.png)

#### 练习2：分组式排名
*素材24：分组中国式排名.xlsx*

​	原表：导入数据，清洗整理——部门升序，金额降序 ，检查数据类型——
​	部门最小排名表：新建辅助表1（复制原表，部门+金额 去重）——添加分组排名列（从1递增）——按部门分组依据，对分组排名列进行最小值处理——
​	部门分组排名表：新建辅助表2（复制原表，部门+金额 去重）——添加分组排名列（从1递增）——合并查询辅助表1，展开最小排名列——
​	【自定义列】部门内排名 = 分组排名列 — 最小排名列 + 1——
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683518274567-6449b03f-b5e1-407f-b1a3-a68d88ac3e96.png)
​	回到原表，合并查询辅助表2（部门+销售额），展开部门内排名列
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683518638061-4745b4af-093f-4743-b158-e72975b734ad.png)

#### 笛卡尔积表
*素材25：生成笛卡尔积表.xlsx*
​	销售表、月份表分别添加相同值的辅助列——合并查询，展开月份列

#### 多行属性合并
*素材26：多行属性合并.xlsx*
![img](https://cdn.nlark.com/yuque/0/2023/png/29687619/1683519122511-59aed6fd-08c4-40e5-915c-84447055d394.png)

​	辅助表：用分组依据求和汇总金额
​	原表：删除金额列——添加索引列——添加后缀\——对索引列进行透视列（不要聚合）——合并销售代表——合并查询辅助表，展开金额列——去掉销售代表的最后一个\（见1.7透视）

## 2、Power Pivot：建模和分析

### 使用场景
​	场景一：已经有数据了，通过寻找表之间的关系字段，建立模型
​	场景二：暂无数据，进行底层建模，一般指在数据库中建立空表 空字段，将字段进行约束管理（主外键）

### 2.1.快速认识Power Pivot
​	素材2：订单明细表.xlsx---（销售记录）
​	素材3：省份区域-2.xlsx---（sheet1）
​	素材4：产品分类-3.xlsx---（sheet1）

#### 创建简单的多表模型
​	需求1. 每个客户省份对应大区的销售金额情况
​	需求2. 每个大的产品组的销售情况是如何的

步骤：
1、导入数据
![image-20220923140406383](D:\VScode\markdown\ images\image-20220923140406383.png)
2、添加建模关系
​	销售记录表【客户省份】---- 省份区域表【省份】
​	销售记录表【产品id】--- 产品分类【产品id】

3、添加度量值：金额 的总和:=SUM([金额])
4、利用可视化完成（透视表）
![image-20220923142851630](D:\VScode\markdown\ images\image-20220923142851630.png)
5、刷新透视表，保证路径不变
6、制作数据看板
![image-20220923152220429](D:\VScode\markdown\ images\image-20220923152220429.png)

要点注意：
​	1、导入数据时，记得提升标题
​	2、建模关系：一端控制多端
​	3、先建度量值，再拉透视表——为了提升计算的规范性和正确率，建议直接在模型中先进行度量值（模型指标）的创建和计算，得到一个具体的值，然后再由维度进行拆解
​	4、若建模文件里没有源数据文件，说明对方不允许你进行修改，只限可视化操作和报表查看。。。若想进行数据修改，必须拥有源数据，并修改连接的绝对路径
​	5、数据指标埋点（简单理解：需要重复使用的计算公式，高频使用的）——当数据内容有更新的时候，该指标在模型中直接进行更新计算，能直接得到结果值。
​	6、模型的最大功能——当数据有更新或修改的时候，可以更改数据源路径或刷新，进行模型的一步到位。

#### 认识Power Pivot
数据视图区
![image-20220923152544227](D:\VScode\markdown\ images\image-20220923152544227.png)

关系视图区
![image-20220812133649722](D:\VScode\markdown\ images\image-20220812133649722.png)

#### 计算区域

##### 计算列
​	1、计算列基于原始数据的行进行计算，通常用于整理原始数据或增加辅助列
​	2、需要将计算结果置于切片器或数据透视表的“行”或“列”时
​	3、基于当前行的计算，比如“[实际送货日期]-[下单日期]”
​	4、对原始数据进行分组，合并等操作
需求1：想知道每个订单的实际配送时长
​	=[实际送货日期]-[下单日期]
![image-20220923154905024](D:\VScode\markdown\ images\image-20220923154905024.png)

需求2：提取出订单的下单月份
​	=MONTH([下单日期])
![image-20220923155643209](D:\VScode\markdown\ images\image-20220923155643209.png)

##### 度量值
​	1、度量值基于数据透视表中所处的单元格上下文进行计算
​	2、需要将计算结果置于数据透视表的“值”
​	3、需要基于此结果计算其它聚合时，比如”平均订单大小“、”自行车销售金额比率“
​	4、如果计算列和度量值都可以实现时，优先选择度量值以节省内存和磁盘空间。

需求1：分析每个月的销售金额情况（不涉及年份）
利用数据透视表
![image-20220923160129446](D:\VScode\markdown\ images\image-20220923160129446.png)

需求升级：轴显示的方式为1月、2月...形式
​    方式一：pivot中修改month公式
​    	=MONTH('销售记录'[下单日期]) & "月"
​    方式二： format 文本格式化函数-----format(值，格式)-----注意格式需要跟着数据类型走，且格式有固定写法。
​    	=FORMAT('销售记录'[下单日期],"M月")
![image-20220923160949632](D:\VScode\markdown\ images\image-20220923160949632.png)
​    方式三：可以直接在数据透视表中拖入日期字段，让其自行进行年月日季度的拆解，留下月份即可。
​	引起问题：坐标轴顺序不对----按列排序(建造数值型一列，用于排序)
​    		建议直接使用数值型字段，或者折中，利用层级关系
![image-20220923161517374](D:\VScode\markdown\ images\image-20220923161517374.png)

##### 关系
​	一端的维度（字段）可以控制多段的值（数值、指标）
​	一端可以连续控制多端的表，通过导向箭头，可以观察其具体控制了哪些表
​		比如：有三张A、B、C    A控制B——B控制C——A就可以通过B间接控制C
素材5、6、7

需求1：想知道每个销售人员的任务额完成度情况
步骤：
​	1、导入数据：素材5、6、7
​	2、建模：架构【销售ID】--- 任务额【销售ID】，架构【销售ID】 --- 销售记录表【销售ID】
​	3、新建度量值：总任务额:=SUM([任务额])，任务额完成度:=SUM[总金额]/[总任务额]
![image-20220926102147273](D:\VScode\markdown\ images\image-20220926102147273.png)
​	4、数据可视化：透视表、透视图
![2023-05-14-13-17-02](D:\VScode\markdown\ images\2023-05-14-13-17-02.png)

==思考1：==
​    当多表中有相同或相似的字段内容（维度），在数据透视表中（可视化过程中）优先选用一端的维度表进行度量值拆分，不可随意选择

==思考2：==
​    当建模完成后，发现值显示不正确，或者显示方式不是想要的，主要原因是：
​    1、跨表拉维度时，拉错了，没有优先使用一端的
​    2、关系创建时匹配错误
​    3、计算/公式错误
​    4、数据类型不对

需求2：想知道不同区域经理下的所有销售代表的任务额完成度情况
步骤：
​	1、建模：职位表【姓名】--- 架构表【销售经理】
​	2、数据可视化：透视图
![image-20220926110750766](D:\VScode\markdown\ images\image-20220926110750766.png)

要点注意：
​	1、建模时，要注意关系的层级。当两表之间可以互相控制时，优先选择符合实际关系的，比如经理控制员工，不能员工控制经理---【一端】经理——【多端】员工
​	2、当透视表的数据不对时，解决方案尽量不要影响源数据，可采用
> 【切片器】筛选
> 【表属性】不推荐
> 单独清洗出一张源数据表——不方便
> 【Dax函数】calculate刷选函数——推荐使用

### 2.2.Dax函数
​    1、所学的80%函数与excel函数相同
​    2、基于列和表的计算
​    3、通过 单引号【引用表】 ，方括号【引用列或度量值】 启动智能感知



#### 运算符
​	算术：+ - * /
​	比较：> < = <>不等于
​	文本连接：&
​	逻辑符：&&（and且）、||（or或）

 

需求1：通过计算，判断出金额是否大于1000，若是返回yes，非no
=IF('销售记录'[金额]>1000,"yes","no")

需求2：找出所有金额大于2000，同时配送时长大于等于5天的数据信息
='销售记录'[金额]>2000&&'销售记录'[实际配送时长]>=5

需求3：找出所有金额大于2000，同时配送时长大于等于5天且销售id为201的数据信息
='销售记录'[金额]>2000&&'销售记录'[实际配送时长]>=5&&'销售记录'[销售代表ID]=201

\#### 函数





 

\##### 不重复计数distinctcount

 

需求1：求客户数量

客户数量:=DISTINCTCOUNT('销售记录'[客户ID])

 

需求升级：想知道不同省份的客户数分布情况

基于1，进行透视表分析

 

要点注意：

\>1、自动汇总进行聚合计算必须位于计算列的正下方，建议替换为使用函数计算，将度量值（指标）集中在一起，便于寻找整理

2、度量值的计算优先使用关系层级最低的那级的数据（多端），便于被引用和整合

 

\##### 关系函数related

 

​    在多端的表中引用/提取一端表中的列值（类似于VLOOKUP）---- 跨表引用维度

需求1：分析各区域的大单信息

步骤：

\>1、导入数据：素材8

2、建模：大单【区域】--- 省份【区域】

3、大区:=RELATED('省份区域'[区域])——默认匹配的依据就是连接中的字段

 

需求2：在销售记录表中对金额进行判断，是否大单，若是返回1，若不是则返回0

=IF('销售记录'[金额]>RELATED('大单定义'[大单最低金额]),1,0)

 

\##### 关系函数relatedtable

 

​    在一端表中提取多端表中的相关行数据 ---- 返回多行多列的表

​    Excel BI中没有新建表功能，Power BI可以

需求1：在省份区域表中求出该省份对应的订单数量

订单数量:=DISTINCTCOUNT('销售记录'[订单编号])

\>=COUNTROWS(RELATEDTABLE('销售记录'))

这种算法可能计算的是未去重的订单数，建议使用度量值直接拆分

 

需求升级：想知道订单量前五名的省份是谁？最终形成可视化透视表+ 前五名的切片器显示

\>订单数量:=DISTINCTCOUNT('销售记录'[订单编号])

排名:=RANK.EQ('省份区域'[订单量],'省份区域'[订单量])

前五名:=IF('省份区域'[排名]<=5,"前五名","")

透视表排序：或者直接选中某列右击---排序

![Alt text](%20images/image-20220926154814635.png)

 

\##### 筛选函数calculate

 

\>=calculate(表达式【度量值/度量值计算公式】, 筛选条件1,[....筛选条件N]）

筛选条件不受自身切片器的控制【即当筛选条件与切片器内容一样时，不会有冲突】

 

需求：求出所有大单的销售金额

大单金额:=CALCULATE([总金额],'销售记录'[是否大单]=1)

 

需求2：计算大单金额比率，并将其放于上方省份排名可视化中，且比率百分比显示

大单金额比例:=[大单金额]/[总金额]

 

需求3：对任务额完成率进行优化

任务额完成度:=CALCULATE([总金额],YEAR('销售记录'[下单日期])=2015)/[总任务额]

 

\##### 安全除法divide

 

\>divide:=DIVIDE([销售额的总和],[任务额的总和])

防止分母为零时，显示错误值

![Alt text](%20images/image-20220926162525272.png)

 

\## 3.常见企业案例

 

\### 3.1.趋势分析

 

需求：

\>这一、两年的每个月的订单情况（销售情况）怎么样？

得到2019年第一季度北区的销售情况趋势看板

 

数据指标：

\>趋势 --- 时间

销售情况 --- 销售总金额、订单数量、客户数量等

 

数据收集：

\>订单明细表

省份区域表、产品分类表

时间表

 

数据预处理：

\>数据清洗、

去重、

查空、

补全、

数据类型统一、

格式统一、

...

 

数据建模：

\>时间表【日期】--- 销售记录【下单日期】

省份区域【省份】 --- 销售记录【客户省份】

产品分类【产品ID】 --- 销售记录【产品ID】

 

数据指标计算：

\>销售总金额:=SUM('销售记录'[金额])

订单数量:=DISTINCTCOUNT('销售记录'[订单编号])

客户数量:=DISTINCTCOUNT('销售记录'[客户ID])

 

解决方案：

\>利用month先提取出数值型月份，可将其作为枪手，也可直接使用它作为可视化的维度列

 

数据可视化：

\>数据透视表/图、power view、power bi、finebi、tabelau等

![Alt text](%20images/image-20220927104143867.png)

 

\### 3.2.年度增长率分析

 

需求：

\>分析今年的销售情况与去年相比是如何的？ --- 年度增长率 YOY

 

数据指标：

\>今年的销售金额

去年的销售金额

年度增长率 YOY =（今年 - 去年）/ 去年

 

数据收集：无

数据建模：无

 

数据指标计算：

\>今年的销售金额

2019年销售金额:=CALCULATE([销售总金额],'时间表'[年份]="2019年")

去年的销售金额

2018年销售金额:=CALCULATE([销售总金额],'时间表'[年份]="2018年")

年度增长率 YOY =（今年-去年）/ 去年

年度增长率YOY:=DIVIDE([2019年销售金额]-[2018年销售金额],[2018年销售金额])

![Alt text](%20images/image-20220927110520276.png)

 

YOY细钻：

同比：今年（这个月）和去年（这个月）的比较

\>同比也可以作为期数之间的比较，但其时间间隔较长，比如相隔一年或几年才开展的下一期

同比：2019年的9月和2018年的9月做比较 --- 【上一个】，是让其自己找上一个，无需指定

![Alt text](%20images/image-20220927111939751.png)

 

环比：这个月和上个月的比较  --- 同一年

\>环比可以作为期数之间的比较，比如同一个活动开展了很多期【相隔时间比较短，比如一年中开展了几期】，那环比就是这一期和上一期的比较

环比：2019年的9月跟2018年的8月做比较 --- 上一个 【数据透视表中有同一年的限制】

![Alt text](%20images/image-20220927112633075.png)

 

\### 3.3.产品分析

 

需求：

\>分析我司的产品销售情况

 

数据指标：

\>销售数量

客户的平均购买金额

 

数据收集：无

数据建模：无

 

数据指标计算：

\>销售数量:=SUM([数量])

客户平均购买金额:=DIVIDE([销售总金额],[客户数量])

 

数据可视化：

![Alt text](%20images/image-20220927134206013.png)

\>量小时，寻找热销产品 --- 前几名，销售额百分比等

量大或维度内容过多时，寻找【八二法则】产品 --- 去整体找关键的内容

80%的销售额来源于20%的产品，，拖尾产品反之同理

 

补充：

\>父行（列）汇总百分比：有层级结构的话，以父级为100%进行

总计百分比：就算有层级结构也按整体合计走

![Alt text](%20images/image-20220927140118804.png)

 

\### 3.4.客户分析

 

需求：

\>根据订单数量对客户进行分组，直接根据订单数量进行判断

![Alt text](%20images/image-20220927141340911.png)

PS：客户分组指标一般都是由公司制定，你没有决定权；或一般也经常在客户系统中使用一个RFM客户价值模型进行价值分组

 

数据指标：

\>客户情况 （未购买、已购买）

订单数量（已购买的客户）

 

数据收集：

\>订单表 --- 目前的数据判断下来，该客户肯定是已经购买过才会出现在该表中 --- 已购买的客户

客户表 --- 最原始的客户信息表，包含了所有客户 --- CRM系统【客户管理系统】中获取

 

数据建模：

\>客户表【客户id】 --- 销售记录表【客户id】

客户表【客户省份】 --- 省份区域【省份】

删除原本的 省份表【省份】 --- 销售表【客户省份】

 

数据指标计算：

\>客户表中获取对应的订单数量

客户分组:=IF('客户表'[订单量]=1,"一次购买",IF('客户表'[订单量]>1,"多次购买","未购买"))

客户表可以直接引用销售表中的订单量度量值【默认按客户id进行维度拆分】

 

数据可视化：

\>![Alt text](%20images/image-20220927145130610.png)

 

\### 3.5.区域分析

 

需求：

\>在某一个区域下看这个区域的销售情况、订单情况、客户情况。

 

数据指标：

\>销售情况

订单情况

客户情况

客户渗透率 = 已购买的客户/客户总数

 

数据收集：无

数据建模：无

 

数据分析计算：客户渗透率

\>需要在客户表中求和客户总数（包含已购买和未购买）

客户总数:=COUNT('客户表'[客户ID])

客户渗透率:=DIVIDE([已购买客户数量],[客户总数])

 

数据可视化：

\>考虑到后续可视化可能需要用到产品切片器，但客户表与产品表无关系，可能会影响到值的拆解，故建议：渗透率指标计算于订单表中，否则会出现表之间的关系，其维度的拆解影响也比较大

![Alt text](%20images/image-20220927150518873.png)

 

\### 3.6.任务完成率分析

 

需求：

\>任务额完成率 --- 人 --- 销售代表

 

数据指标：

\>任务额完成率  = 实际销售额/目标任务额

 

数据收集：

\>任务目标表

销售人员架构

 

数据建模：

\>任务额【销售id】---架构【销售id】

客户【销售id】---架构【销售id】

——考虑到每个销售员的月份任务额指标不固定，可通过时间表来控制，故在任务额表中添加日期辅助列：=DATE(2019,'销售人员任务额'[月份],1)

任务表【日期辅助列】---日期表【日期】

 

数据指标计算：

\>总任务额:=SUM([任务额])

任务额完成度:=DIVIDE([2019年销售金额],[总任务额])

 

数据可视化：

\>![Alt text](%20images/image-20220927153632751.png)

 

\### 3.7.销售排名分析

 

需求：

\>对销售人员进行排名分析。权重占比【绩效指标】，多方面进行考量

![Alt text](%20images/image-20220927155722940.png)

 

数据指标：

\>最终排名分数:=任务额完成度排名 * 50% + YOY排名 * 30% + 渗透率排名* 20%

 

数据收集：无

数据建模：无

 

数据分析计算：

\>1、在架构表中分别得到三个指标的度量值（即该人员的指标值）

——数据量太大卡bug了，在引用度量值的时候会出现如下报错，直接点击确定，鼠标点到空白处随意点击切换到任意一张表上，再切换回来，会发现有计算错误，点击错误直接计算即可

![Alt text](%20images/image-20220927160611345.png)

![Alt text](%20images/image-20220816111518206.png)

2、对三个指标分别进行正常排名计算，其排名值就是该指标的分数值

3、将上方得到三个指标的排名值 * 权重比例，并相加 --- 最终的总分

——最终排名分数:='销售人员架构'[渗透率排名]*0.2 + '销售人员架构'[YOY排名]*0.3+'销售人员架构'[完成率排名]*0.5

4、将权重的得分进行排名，注意现在是值越小越往前排

——最终排名:=RANK.EQ('销售人员架构'[总分],'销售人员架构'[总分],ASC)

![Alt text](%20images/image-20220927162413065.png)

 

数据可视化：KPI创建

\>已有数据指标（权重指标），无需在做额外计算，位置在：pivot内部—主页—选中度量值后—创建KPI，设定目标量

![Alt text](%20images/image-20220927163138778.png)

![Alt text](%20images/image-20220927163617004.png)

![Alt text](%20images/image-20220927163401191.png)

 

==将企业案例的7个分析制作完整的看板，需要有标题、切片器，参考趋势分析看板==

 

\## 4.O2O平台功能优化分析报告

 

\### 4.1.理解行业

 

行业：O2O、OTO——将线下的商务机会与互联网结合，让互联网成为线下交易的平台

 

背景：

 

​    某互联网大厂对自己的O2O平台进行了功能优化，对提供给ktv商户使用的预定功能进行了调整，希望帮助这些商户提高成交。新功能进行了灰度上线（部分特定用户可以看到新功能）。

 

==灰度测试==：指定人群或随机抽取部分用户先行体验测试

 

需求：

\>需要对灰度上线的地区的运营数据进行新功能上线前后数据对比分析，对新功能达到的效果进行评估，提供报告。

![Alt text](%20images/image-20220816141223208.png)

 

报告呈现三个步骤（Excel或者ppt形式）

\>1、此平台的现状分析

提示：预定功能优化前商户的整体交易额不是很理想，因此希望通过功能优化来提升交易额。可以列出功能优化前具体的交易额情况。

2、功能优化前后的各项数据指标情况的对比

提示：不仅仅局限在交易额上，从更多的维度和指标上对功能优化前后数据指标进行对比，更全面的体现出功能优化所带来的影响。

3、对此优化功能的建议和意见

 

\### 4.2.理解业务部门提出的数据需求

 

本项目用户通过PC端或者移动端来访问O2O平台，看到某个感兴趣的KTV，点击进去浏览相关信息，觉得不错，点击预定功能，查看可以预定的时间，找到合适的预定时间进行预付款

 

补充：

\>在此过程中其实出现了一个用户行为，出现了漏斗行为

用户访问平台 1w ---- 浏览 6k ---- 预定 2k ---- | ---- | ----| ---- 付款 200（平台上付款）

 

==UV==：独立访客，不管你在pc端还是移动这一天内上上下下多少次，只要登陆的是一个账号，都属于一个人，而不是多个

 

预设数据指标：

\>预定金额

交易金额

预定/交易占比

预定/交易转换率

预定/交易客单价

日均UV

 

\### 4.3.根据需求收集相关数据

 

\>不要只局限于业务部提供的数据上

![Alt text](%20images/image-20220928102127304.png)

 

\### 4.4.对数据进行预处理、清洗

 

数据理解

\>1、对数据的每个字段都看一遍，看是否有特殊的业务含义以及通过基础筛选可去观察数据是否有不正常的地方

2、4MB 约等于4w多条数据；若文件大小超出20MB，就不能再随意的用excel打开

3、一般从系统中导出或业务部提供的类型为csv偏多，或是excel文件

————若是csv文件，注意另存为excel，因为它没有可视化保存功能，只是个纯文本文件，没有单元格和可视化的操作！

![Alt text](%20images/image-20220928102934568.png)

 

数据处理

\>1、店铺类型：优质>普通>低质>长尾

——长尾指的是以前有合作，但现在没怎么合作的商家，有点类似拖尾品牌

2、店铺类型和名称均删除空值对应行

3、城市与区域有空值（103条），先判断是否有意义，再考虑删除或填充

——通过观察该数据均为长尾店铺，且测试账号为多，故直接删除即可

——城市为空但区域不为空的（8条）——从数据表中查找该区域是否还有其他数据条，有对应城市的，直接复制填充，或者百度

——考虑数据量大小，若能填充则优先填充，这些数据是否会对分析有过大的影响，若判断下来无伤大雅则可以选择性删除

4、营业状态：指获取数据时的营业状态，而不是数据对应的时间的相应状态

5、数值字段均有空，通过判断和理解，可以以0填充

——对优化前后数据值字段统一将空值填充为0

 

数据预处理的具体思路

\>1、数据录入  --- 表格设计，数据验证

2、查看是否有单元格需要合并，或有需要拆分的

3、查看数据量：数据行（数据条）以及列数（字段）

4、检查数据的完整性和唯一性，空值、重复值

5、因单元格的拆分导致的空格，数据空格处理

6、检测数据类型

7、查看数据的均值、中位数等基本数据统计信息 --- 箱型图

![Alt text](%20images/image-20220928110902705.png)

8、查看数据的整体分布 --- 直方图

![Alt text](%20images/image-20220928110939458.png)

 

\### 4.5.对数据进行数据指标的计算与分析

 

步骤：

\>1、删除城市和区域为空值的数据

——删除时，右击，删除行，不要直接delete

2、空值填充，用0补位

——优先考虑空值是否有意义，可以先通过上下文理解，或找业务人员询问是否真有空缺。若有，考虑是否与分析相关，连续前后字段填充均值、0等补位；如果是拉取过程中产生的错误，就需要重新获取数据重新做。

3、将优化前后的pc和app的uv相加，得到日均uv

4、精确合并数据

——为保证数据的一致性，需要将两表进行合并，找到合并的依据字段，没有符合匹配的字段时，可选择合并城市+区域+店铺名称，作为辅助列查找依据，让其尽可能的趋向于精确

5、简化字段，将多余字段删除

——清洗过程中，尽量先保存一个副本，保留（预处理后的数据）及源数据。本项目是个csv文件，请另存为excel！

6、设计表格

利用查找函数将优化后的数据匹配至优化前的表格内,注意观察数据顺序

![Alt text](%20images/image-20220928112407300.png)

——检查发现有报错存在，共221条数据。——分析原因：在匹配过程中有匹配不上的数据，部分店铺没有在测试名单内，同时我们合并的匹配依据也不是真正的唯一值，也会有一定影响；而需求主要是为了对比分析，若无数据对比，则无意义了，故直接选择删除

——若发现报错是有效的，则该单元格必须有内容存在，但不能是以报错显示，会影响他人对你数据处理的可信度，同时报错单元格也无法做其他的统计等操作，可以利用iferror函数对报错内容进行替换填充——比如：=iferror(VLOOKUP(E2,优化后!E1:M$14366,5,FALSE),0)

7、添加指标计算

![Alt text](%20images/image-20220816153241373.png)

1）预定转换率 = 预定订单数/(日均UV*7) --- 一周的数据

2）预定客单价 = 预定交易额/预定订单数

3）交易转换率 = 交易订单数/(日均UV*7)

4）交易客单价 = 交易额/交易订单数

5）预定占比  = 预定订单数/交易订单数

8、添加字段

——用优化后数据与优化前的数据进行比较 （后对前），利用if判断，返回值：上升、下降、不变；

![Alt text](%20images/image-20220928140331710.png)

9、设置自动保存：Ctrl + S

![Alt text](%20images/image-20220928141823856.png)

 

\### 4.6.对数据进行可视化（看板）

 

一般先看整体（对比），再从多个维度去更细地观察与分析数据

\>1、店铺类型

2、城市

——城市内容过多，不利于整体分析的，可考虑将其进行分组进行整体分析 --- 城市分类（1、2、3.... 线/其他城市）

3、父品类

![Alt text](%20images/image-20220928142629674.png)

 

作业1：通过不同维度，及不同指标制作数据透视表分析，可参考：O2O平台功能数据透视表参考.pdf

 

\### 4.7.整理数据分析报告

 

内容：

\>1、需求

2、平台现状（作为功能的优化，必须分析现状，引出需要优化的原因，同时可以表达出数据的量，样本店铺数等等）

3、可视化分析（【可视化图】--- 配小结文字）

4、项目总结（最好能展现点数字，领导喜欢，数字更具说服性）

5、建议（通过结果给出相对可实施的建议不要过于笼统【一定要有】！！！！）

 

根据上方分析的数据透视表，插入各种图形，选择合适的图形，注意图上添加标题、以及是否需要数据标签等。

该图形在后续的ppt报告中一般以截图放进去即可，不需要一直考虑能不能ppt直接插入可视化图表或联动power bi。

可参考：O2O平台功能优化效果评估报告参考.pdf

 

\## 5.Power BI Desktop

 

\### 5.1.界面介绍

 

![Alt text](%20images/image-20220928152022613.png)

 

\### 5.2.获取数据

 

​    1、普通数据源导入：获取数据

​    2、数据模型导入：导入Query、Pivot、View

练习：将素材中的【常用企业案例】迁移到PBI中

 

\### 5.3.界面与功能

 

​    1、报表视图：power view 、power map

​    2、数据视图：power pivot --- 数据视图（计算区域）

​    3、模型区域：power pivot --- 关系视图

​    4、power query：主页 --- 转换数据

​                    文件 --- 获取数据

 

\### 5.4.可视化图形展示

 

1、不同的图形代表的含义不同：

\>柱状、条件：元素之间比较

折线：时间 --- 趋势、走势

饼图、环形：占比、比例

散点、气泡：（x、y、z数值）

组合图：当轴值字段单位不同时候

切片器：筛选的可视化

地图：地区分布

卡片图： 直观的展示数据值（关键指标卡）

![Alt text](%20images/image-20220928154233009.png)

 

2、不同的图形需要有不同的必要值：

\>字段的数据类型

以及维度表的选择挂钩

 

\### 5.5.快速上手PBI

 

\#### 散点图制作

 

需求：观察各个产品的销售金额与订单数据量及其单价间的情况

该趋势分析与时间挂钩，可以给散点图添加播放轴【月份】

![](%20images/2023-05-15-10-29-56.png)

 

\#### 区域分析

 

需求：展示每个区域省份每个销售代表的销售金额分布情况

第一次使用地图可能需要开启安全机制，地图不可用时，换成其他图形展示，或下载第三方地图

![Alt text](%20images/image-20220928162412189.png)

![](%20images/2023-05-15-10-35-45.png)

 

==PBI社区看板作品分享==：http://www.chinapowerbi.com/Activity.html

 

\#### 数据标签的值显示方式

 

需求：产品分类的销售金额占比情况，且显示其数据标签

\>1、格式 ---数据/类别标签按钮（主）

2、详细信息标签 --- 标签内容

3、添加一个可视化表格，进行辅助分析；同时值可以进行值字段设置为百分比形式

![Alt text](%20images/image-20220929101317170.png)

 

\#### 向下钻取功能【数据深钻】

 

需求：利用钻取功能找到销售金额最高的年份，并从该年份中找到最高月份，再从该月份找到最高的日期

\>当轴上有多层字段的时候，比如：年 --- 季度 -- 月---日；区域---省份---城市；产品分类---产品子分类--产品名称....

图表右上方会显示钻取按钮，点击开启即可在图表上进行向下的数据钻取；比如点击某个年份，可以直接下钻到该年份的季度上

默认钻取功能是不开启的，不开启的话 点击图表就是简单的图表联动筛选

![Alt text](%20images/image-20220929102119386.png)

 

\#### 常用筛选器

 

\>1、视觉级筛选器 -- 应用于当前图表的筛选（若当前页面的其余图形上也有该字段或相关字段，也充当了页面级筛选器）

2、页面级筛选器---应用于当前页面上的所有图表【切片器功的功能】

3、报告级筛选器 ---应用于整个项目的所有页面，以及每一个页面中的所有图表的筛选

 

\#### 报表总页

 

类似仪表板（但不完全，还是需要自己作图排版），目的用于多角度进行查看和分析

\>比如：某公司销售情况分析

1、产品销售分析

2、各区域的销售情况分析

3、销售代表的销售情况及完成率分析

......

![Alt text](%20images/image-20220929105938200.png)

 

\#### 组合图制作

 

![Alt text](%20images/image-20220929105607794.png)

 

\### 5.6.PBI在线版

 

\#### 发布分享

 

主页【发布】 --- 网页端【编辑】

![Alt text](%20images/image-20220817144749977-1664414436484.png)

 

\#### 仪表板

 

选中所需图形，右上角【固定视觉对象】--- 新建/现有仪表板

我的工作区【类型】--- 点击转跳到具体图形界面

![](%20images/2023-05-15-10-59-30.png)

 

\#### 问与答

 

智能化，根据所做项目内的图形、模型自行进行的分析，该工具可以自己进行一些常规的分析图表制作和结论，然后通过该功能快速得到答案

![Alt text](%20images/image-20220817150038813-1664414436484.png)

 

\#### 共享

 

不免费

![Alt text](%20images/image-20220929111944686.png)

 

\### 5.7.PBI数据整理

 

需求：产品在下单月份的销售汇总情况（产品细化到产品分类级别即可）

 

\#### 1、导入数据

 

将门店销售记录导入pbi的query编辑器

\>\11-20220928-Excel项目 Powerbi基础一--笔记与项目参考\所用素材\powerbi操作素材\操作素材\02-门店销售记录

 

\#### 2、清洗数据

 

将两个门店数据合并到一起，命名：销售数据，分类好门店数据（先添加辅助列店名）

![Alt text](%20images/image-20220929112706300.png)

 

\#### 3、合并查询

 

将产品分类表导入编辑器中，并将产品分类合并查询到“销售数据”中，id--id，展开产品分类字段

 

\#### 4、导入时间表和省份区域表

 

时间表清洗：转换【日期】年、月份

![Alt text](%20images/image-20220817151431912-1664414436484.png)

 

\#### 5、新建组别【文件夹】并应用

 

右键新建组---放入源数据（一二店），关闭并应用（上载），隐藏一二店

![Alt text](%20images/image-20220929113428693.png)

 

\#### 6、创建模型

 

\>销售记录【产品id】---产品分类【产品id】

销售记录【下单日期】---时间【日期】

销售记录【省份】---省份区域【省份】

 

\#### 7、新建度量值

 

需求：利用表格展现不同产品分类的销售总金额与订单数量情况

\>销售总金额 = SUM('销售数据'[金额])

订单数量 = DISTINCTCOUNT('销售数据'[订单编号])

——移动度量值位置：点击度量值---度量工具【主表】下拉

——注意：度量值参数尽量以“`表`[字段]”的完整形式写入

![Alt text](%20images/image-20220929140148877.png)

 

\#### 8、新建列

 

需求：使用dax函数在销售记录表中得到客户省份所对应的大区、公路自行车的销售总金额（度量值）

\>大区 = RELATED('省份区域'[区域])

公路自行车销售总金额 = CALCULATE([销售总金额],'产品分类'[产品子分类]="公路自行车")

 

\#### 9、新建表

 

\>1）手动输入或复制源数据表 ---【临时模拟数据可视化效果等常用】

2）连接回表 --- 利用dax函数返回新表

relatetable：单独使用相当于拷贝数据表————表 = RELATEDTABLE('销售数据')

summarize：返回一张摘要表，显示对一组数据的分组汇总情况【分组依据函数化】

summarize（表，分组依据1，[分组依据2...]，新列名1，聚合操作字段表达式1，[新列名2，聚合操作字段表达式2...]）

![Alt text](%20images/image-20220929142508746.png)

 

需求1：得到不同客户省份的汇总金额表

\>省份金额汇总 = SUMMARIZE('销售数据','销售数据'[客户省份],"总金额",[销售总金额])

 

需求2：得到不同客户省份，不同产品分类的销售金额和销售数量情况表

\>省份金额汇总 = SUMMARIZE('销售数据','销售数据'[客户省份],'产品分类'[产品分类],"总金额",[销售总金额],"总数量",SUM('销售数据'[数量]))

![](%20images/2023-05-15-12-24-01.png)

 

\#### 10、分析需求

 

需求：产品在不同年份下的销售汇总情况

\>当多表之间的时间年份不一致时，1）可直接采用下单时间作为维度；2）回到源数据表增加缺少的年份数据列（excel制作好复制粘贴；先拆分为年月日列，替换年列14为16，再合并列）

 

\## 6.市场分析项目实战(孕妇装)

 

\### 业务需求

 

\>1、对每个类目的成交量数据进行统计汇总分析

2、求2017年与2016年的成交量环比增长及2017年与2016年各个月份的同比增长分析

3、根据已有数据对品牌集中度进行分析

 

\### 数据指标

 

\>每个类目的成交量的统计汇总分析

同环比增长分析

品牌集中度

定价分析

 

\### 数据源

 

\>从业务部获取相关数据，通过观察和理解，分为：

1、一级类目【孕妇装-孕产妇用品-营养行业数据2016-2017】

2、二级类目【妈妈产前产后用品行业数据2016-2017】

3、护腰枕的品牌数据、属性数据、搜索数据

![Alt text](%20images/image-20220929150223340.png)

 

\### 数据理解

 

1、【孕妇装-孕产妇用品-营养行业数据2016-2017】共13个二级类目样本数据

2、【妈妈产前产后用品行业数据】大体可以将数据源分为行业数据和搜索数据

\>行业数据：

  （1）名称：在类目数据，名称指的是子类目名称；在属性数据，指的是属性值；在品牌数据，指的是品牌名。

  （2）年月：数据对应的年月，在Power BI Desktop中艺年月日格式显示。

  （3）成交量：统计对象在特定时期的市场销量。

  （4）销售额指数：统计对象在特定时期的销售额，经过指数化脱敏的数据。

  （5）高质宝贝数：在淘宝市场中高于平均销量的商品数。

  （6）属性：商品的属性。

  （7）数据类别：数据集对应的数据类别，如类目数据、品牌数据、属性数据。

  （8）类目：数据集对应的父级类目

搜索数据：

  （1）宝贝标题：商品的标题

  （2）销售（人数）：成交的客户数

  （3）售价：淘宝上的折扣价

  （4）预估销售额：根据销售人数和售价计算的产品销售额

 

\### 数据加载、清洗

 

导入数据---删除多余列---替换空值---去重---检测数据类型---修改标题

 

\### 数据建模

 

表类型

\>1、维度表（一端的表）：看做用户分析数据的窗口，包含了事实数据表中事实的特性（维度值），有些特性同时提供描述性信息，有些指定如何汇总事实数据表数据，包含了帮助汇总数据特性的层次依据

2、事实数据表（多端的表）：可能包含业务销售数据，如网店每天产生的数据，通常包含大量的行，每个数据仓库（kettle）都包含一个或多个事实数据表。特点：包含数字数据（事实），并且这些数字信息可以汇总操作，为提供公司作为历史的数据

 

事实数据表中的度量值

\>1、可以累加的度量值，最有用（最有意义的度量值） --- 总销售额、总数量、总客户数...

2、非累加的度量值，汇总结果一般是没有意义的，但若求个平均值就意义了

 

寻找匹配关系

\>找不到一对多的关系时，手动创建辅助表/辅助列，进行时间维度的控制

——选择某一张表的年月列 --- 右击 --- 作为新查询添加 --- 到表（正式转换成表格形式） --- 确定 --- 修改字段名或表名 --- 数据类型统一 ---去重

![Alt text](%20images/image-20220929153721266.png)

 

添加属性维度表

\>![Alt text](%20images/image-20220929155847558.png)

 

建模关系

\>年月【年月】 ---- 各表的【年月】

分类属性【分类属性】 --- 护腰枕属性数据【属性】

 

建模常见问题

\>1、为什么这两张表无法建立关联？--- 关系上是否没有找对字段，没有一对多

2、为什么计算出来的结果和真实的结果不一样？--- 基于上方的解决方案，考虑是否拉错维度表的维度或值了以及在考虑公式中用了那些表数据，公式与维度之间也会有相互的影响

3、为什么图表显示的数据和计算中的不一样？--- 优先考虑数据类型和维度内容

4、为什么创建好关系后其结果值显示的不是我想要的？--- 考虑表结构是否拉错字段，以及计算公式中维度内容和拆分依据的维度表之间的关系，因为度量值与维度之间相互影响

 

\### 数据可视化

 

![Alt text](%20images/image-20220929160844100.png)

需求：对营养品行业的每个类目的成交量的统计汇总分析

\>![Alt text](%20images/image-20220929161956685.png)

分析结论：

在此类目中2016-2017年成交量最高的为：孕妇裤，占比19.47%；其次妈妈产前产后用品，占比18.98%，最低......；而我们需要投放的市场类目为妈妈产前产后用品，其市场的需求量和成交量还是可观的，属于营养品行业第二名。

 

需求：在营养品行业中知道每个类目的趋势变化情况

\>1、分区面积图：每个类目内容以图层进行叠放，观察其高低及面积占比

![Alt text](%20images/image-20220929163026288.png)

2、堆积面积：上下观察 --- 趋势相对越平稳的再越下面，趋势起伏越大的越在上；面积分布 --- 数据具体的占比情况

![Alt text](%20images/image-20220929163123604.png)

3、通过筛选器得到成交量前三的数据内容 --- 临时性筛选查看

![Alt text](%20images/image-20220929163540005.png)

——永久排名做法：先针对维度进行数据汇总 --- 排名，得到名次后将其作为切片器进行

 

\#### 切片器

 

\#### 钻取筛选器

 

\>1、创建页面【钻取页面】，添加图形，添加字段到钻取筛选器

![Alt text](%20images/image-20220930101114162.png)

2、新开一页，添加图形，选中图形某条目，右键，钻取页面，自动跳转到带钻取筛选器的页面【钻取页面】，同时显示的是类目筛选过后的数据内容

 

\#### 数据钻取

 

\>选中图形，【数据/钻取】钻取操作

1、向下钻取：针对某个数据项进行深钻，比如单次点击2017年 --- 2017年的各个季度....

2、展开下一级别：叠加展开，点击一次即可在年的基础上添加季度 --- 月--- 日（数据越来越具体）

![Alt text](%20images/image-20220930101635736.png)

3、切换到下一级别：基于数据的层次结构，进行分层数据相加，比如依次按年---季度---月---日4个层次表示，比如季度，则展示的是16年和17年同个季度的总和

![Alt text](%20images/image-20220818144823929.png)

 

需求：得到营养品行业不同年份下不同季度的成交量情况，需要区分年份与该年份的季度

 

\#### 编辑交互

 

\>![Alt text](%20images/image-20220930102937054.png)

选中图形，格式，开启【编辑交互】

1、筛选：当选择某个数据时，图上只显示该数据内容 【表格和折线类图形默认】

2、突出：高亮显示【图形默认】

3、无（禁用）：无效果，不做交互

 

\### 分析指标计算

 

\#### 同环比增长分析

 

同环比率 = （总成交量 - 上一年【上一月】成交量）/ 上一年【上一月】成交量

\>1、同比：衡量这个指标与去年同期的相比，今年的这个月与去年的这个月的比较

同比 = （今年 - 去年）/ 去年   或者  今年/去年 -1

2、环比：衡量这个指标与上一期的比较，这个月与上个月的比较

环比 =（这个月 - 上个月）/ 上个月   或者  这个月/上个月 -1

 

新增度量值

同比

\>1、营养品行业成交量 = SUM('孕妇装-孕产妇用品-营养行业数据2016-2017'[成交量])

2、营养品行业上一年成交量 = CALCULATE([营养品行业成交量],DATEADD('孕妇装-孕产妇用品-营养行业数据2016-2017'[年月],-1,YEAR))

3、营养品行业同比 = DIVIDE([营养品行业成交量]-[营养品行业上一年成交量],[营养品行业上一年成交量])

 

环比

\>1、营养品行业上一月成交量 = calculate('孕妇装-孕产妇用品-营养行业数据2016-2017'[营养品行业成交量],DATEADD('孕妇装-孕产妇用品-营养行业数据2016-2017'[年月],-1,MONTH))

2、营养品行业环比 = divide([营养品行业成交量]-[营养品行业上一月成交量],[营养品行业上一月成交量])

 

![Alt text](%20images/image-20220930111937097.png)

![Alt text](%20images/image-20220818161123280.png)

注意：

\- 由于会有日期的拆解，故今年的成交量直接使用总成交量的度量值即可，他会自动进行拆分

\- 由于公式内dateadd函数依据的年月参数为营养品行业的年月列，故拉表可视化的时候也需要日期维度的统一【即也拉该表的日期】

 

时间智能函数：dateadd（日期，间隔，单位） --- 指定间隔移动后的日期

 

\- 第一个参数：进行平移计算的日期列（优先使用当前表的日期列，一般不使用维度表进行）

\- 第二个参数：偏移量，正整数向未来偏移【下N个】；负整数向过去偏移【上N个】

​    - 比如1表示的下一年、下一月等；-1表示上一年、上一月。

\- 第三个参数：偏移的单位：年year、月month、日day、季度quarter

 

\#### 品牌集中度

 

品牌集中度是用于评判市场品牌生存空间的核心指标

\>常用分析法则：8020法则——80%的销售额来源于20%的品牌

用积累占比画出帕累托图观测品牌集中度，观察数据，是各个品牌在各个月份的销售数，这里选取销售额指数进行分析度量

 

需求：利用dax函数得到各品牌的总销售额指数情况表 ---- 品牌汇总表

\>1、创建品牌汇总表，同时将销售额指数进行降序排序，因为指数越高其品牌在该市场的价值就越高

——品牌汇总 = SUMMARIZE('护腰枕品牌数据2016-2017','护腰枕品牌数据2016-2017'[名称],"销售额指数",SUM('护腰枕品牌数据2016-2017'[销售额指数]))

2、累计占比【从高价值往低价值进行累计（排序意义）】

![Alt text](%20images/image-20220930134649125.png)

3、计算累加方式一：FILTER

=SUMX(FILTER('销售记录',RELATED('省份区域'[区域])='区域经理'[区域]),'销售记录'[金额])

![Alt text](%20images/image-20220930140507648.png)

4、计算累加方式二：

累加 = SUMX(FILTER('品牌汇总',EARLIER('品牌汇总'[销售额指数])<=[销售额指数]),'品牌汇总'[销售额指数])

![](%20images/2023-05-16-15-33-45.png)

5、计算累加占比

累加占比 = [累加]/SUM('品牌汇总'[销售额指数])

![](%20images/2023-05-16-15-35-53.png)

6、进行排名

排名 = RANK.EQ([累加占比],'品牌汇总'[累加占比],ASC)

![](%20images/2023-05-16-15-37-40.png)

7、数据可视化

透视表排名列：不汇总 --- 帕累托图（组合图+参考线）

——插入参考线作为8020的分界点，形成品牌的左右对比，左侧的作为整个市场的主体品牌，右侧为长尾品牌。

——其中折线的拐点（折率）可用于不同市场品牌集中度的对比，折率越大说明品牌越集中

![Alt text](%20images/image-20220930144910886.png)

分析结论：

——按排名升序，发现前15个品牌的累计占比【市场份额】正好超过总份额的80%。

——而该数据的品牌样本共62个，故（15/62)24.19% 的品牌占领了80%的市场份额；或（12/62）20%  的品牌占领了73.41%的市场份额。

——四舍五入，按8020原则作为参考，20%的品牌正好占80%的市场份额，故该品牌市场还有一定的生成空间，可以进行投放

——折线在第五个品牌出现了明显的拐点，说明前五个品牌相对高度集中，销售额指数基本都集中于此，之后相对分散，而前15个品牌均为本市场的主体品牌

 

补充：

 

\- SUMX（表，表达式）：返回每一行计算的表达式之和

\- FILTER(要筛选的数据区域，筛选条件，[找不到结果返回的值])

\- EARLIER（列名，[外部计算传递到的整数]）：拷贝所有数据内容

 

\#### 计算价格段分组

 

产品定价将直接影响产品在投放市场的竞争力和消费者对品牌的认知。

由于 价格维度过多，可以使用分组分析，利用PBI的分箱操作，对价格进行分段

\>选中字段，右键【新建组】，分箱

![Alt text](%20images/image-20220930150409622.png)

 

补充：

组类型：

 

\- 箱：不固定内容，以取值范围或设定箱数来自行匹配装箱分组

\- 列表：固定的内容，自定义分组

 

装箱类型：

 

\- 装箱大小：给定取值范围，然后PBI自行将数据进行匹配，比如给定100位一箱，则判断0-99；100-199...

\- 箱数：指定装箱箱数后，数据按聚类分析放入箱子里

 

可视化结论：

![Alt text](%20images/image-20220930150747135.png)

——观察分析，市场定价在100--199之间表现最好；下钻分析，发现155--160之间表现最好，在搜索数据中得到最好的一个价格是158，可以作为产品的定价参考

 

因素分析（SWOT分析）：

基于企业内外部竞争环境和竞争条件下的态势分析：S---优势；W---劣势；O-- 机会；T---威胁，该分析得到的结论带有一定决策性；故某种意义上来说隶属于公司内部分析方法，即根据企业自身条件在既定内进行分析

 

\## 7、客户分析项目实战

 

\### 业务背景

 

随着电商的发展，电商企业获取客户的成本越来越高。据统计，现在获取一个新客户的成本为100~1000元，产品的毛利率越高，获取新客户的成本也就越高。对比获取新客户，获取一个老客户的平均成本不到10元，于是越来越多的电商企业开始重视客户分析并付诸实践，因为客户分析师研究如何降低成本、如何提高老客户回购率等问题的重要支撑。

 

\### 项目需求

 

\>了解客户价值

了解我们可以从哪些客户上获取利润，哪些客户会让企业亏本

客户的生命周期和地区分布情况

 

\### 数据 指标

 

\>客户地区分布

流失客户

客户生命周期

客户价值分组 --- RFM价值模型

 

\### 数据源获取

 

![Alt text](%20images/image-20220930151909817.png)

 

\### 数据 理解

 

宝贝表：

\>订单编号

价格

购买数量

商品编码/外部编码：货号

 

订单表：

\>订单编号

买家会员名：每个消费者ID

买家实际支付金额

买家应付货款

订单创建时间

订单付款时间

订单状态：包含卖家已发货，等待确认；交易关闭；等待买家付款；交易成功

收货地址

 

成本表：

\>商家编码：货号

采购价：成本价

品类：产品品类

 

\### 数据清洗、建模

 

清洗：去重、替换空值、提升标题等

建模：订单表【订单编号】--- 宝贝表【订单编号】

 

\### 指标计算

 

需求：

\>利用可视化表格统计地区的客户数量情况（省，以及需要是已购买的客户数）

——客户分布的省份进行分析，研究各个省份的业绩和客单价等指标，指导并调整企业的推广策略

 

步骤：

\>提取省、市、区信息（复制收货地址，按分隔符拆分列）

![Alt text](%20images/image-20220930155550331.png)

这里不能用订单付款时间作为筛选，因为交易关闭也有订单付款时间内容【付款后退货的】

 

需求：

\>计算人均消费水平（人均客单）--- 人均客单=总金额/人数

——不同的地域客户消费水平不同，通过统计不同地域客户的销售金额，了解产品在不同地域的消费力情况

 

步骤：

\>1、总金额 = SUM('订单表'[买家实际支付金额])

2、人均客单 = [总金额]/DISTINCTCOUNT('订单表'[买家会员名]) = COUNTROWS(VALUES('订单表'[买家会员名]))

——values（表或列）：返回一个不重复值的表或列----删除重复项的公式化

![Alt text](%20images/image-20220930160535377.png)

 

分析结论：

\>销售业绩排名前五的地区分别是广东、上海、江苏、浙江、北京；

1、其中浙江的任何客单低于其余四个省，差距还是较大的，可以重点分析该地区的销售订单；

2、同时北京的客单价属于第二高，但业绩和人数垫底，故也可以重点分析，看是否需要调整或重新指定投放策略或营销方案；

3、在广告方面对于广东、上海、江苏可以加大或优化投放策略

 

\### 地域分布四象限图

 

\>1、导入第三方图形

![](%20images/2023-05-16-19-10-53.png)

x轴（人数）---- 规模。越往右，值越大 --- 规模越大

y轴（客单） --- 客单，越往上，值越大 ---客单越大

散点形状大小--- 总金额，销售额

![Alt text](%20images/image-20220930161525579.png)

2、修改象限分布名称

![Alt text](%20images/image-20220930161813271.png)

3、调整散点图数据分布

原因：客单价的y轴取值范围默认从0开始，但最低客单是170.5

![Alt text](%20images/image-20220930162332846.png)

 

分析结论：

\>1、低规模高客单的地域可能是因为广告投放不到位或者市场营销不到位，可以考虑适当加大市场投入，刺激会员规模增长。

2、高规模高客单的地域是重点维护的地域，要保持市场投入和营销策略，甚至可以考虑加大投入

3、低规模低客单的地域在精力有限的情况下可以放弃，在精力足够的情况下可以开展调研等工作，研究该地域市场的拓展方案。

4、高规模低客单的地域可以尝试投放组合优惠套餐，提高关联销售，从而提高客单。

 

\### 流失客户分析

 

**统计流失金额**

需求：

\>消费者下单后如果不付款，就会导致订单关闭，淘宝订单在下单后24小时内不付款就会自动取消。

通过分析流失订单的共性和成功订单付款的平均时间间隔，找到降低客户（订单）流失率的方法。

 

![Alt text](%20images/image-20221006094345603.png)

结论：

通过统计得到的流失情况：流失总金额96845元，流失的人数381人。

 

**计算付款时间间隔**

由于淘宝机制是24小时不付款自动取消，故先以小时为单位进行计算，后续再以分钟为单位进行，通过下钻功能分析间隔的规律

\>1、付款时间间隔（小时） = DATEDIFF([订单创建时间],[订单付款时间],HOUR)

2、付款时间间隔（分钟） = DATEDIFF([订单创建时间],[订单付款时间],MINUTE)

![Alt text](%20images/image-20221006095544895.png)

注意时间差的变化是否合理，单位之间进行专门的M函数换算，提高准确率

datediff（起始时间，结束时间，时间单位）---返回两个日期之间的单位间隔（可指定单位）

 

需求：

\>选择合适的可视化将间隔时间细化到分钟上，完善整个间隔分析

注意筛选器的应用位置

![Alt text](%20images/image-20221006100459323.png)

注意时间间隔的钻取

![Alt text](%20images/image-20221006101221963.png)

 

分析结论：

\>1、从下单到付款时间在1小时之内的付款率最高，若超出一小时还未付款的，客户和订单的流失较高；

2、同时通过分钟间隔可知直接付款的人数偏多（即在详情页面直接付款）

3、另外1分钟之内的付款率较高，故可以考虑在下单后的1分钟之内设置有效的催单机制

 

\### 客户生命周期

 

需求：

\>通过研究客户生命周期指定客户回访方案，计算每个客户最近消费的时间间隔，根据客户最近消费的时间间隔比例，确定客户生命周期。

 

步骤：

\>1、复制订单表，留下会员名和付款时间列，并去除null值

![Alt text](%20images/image-20221006101916961.png)

2、通过分组依据将该会员的所有付款时间数据汇聚到一起形成数据表

![Alt text](%20images/image-20221006102140950.png)

——当前拿到的是多行多列的数据表，无法直接利用付款时间列进行间隔计算，必须拿到该表中单独的时间列，按list的方式进行间隔计算

3、修改M函数

主页【高级编辑器】---分组的行---修改代码：

each _, type table [订单付款时间=nullable datetime, 买家会员名=nullable text]————each[#"订单付款时间"],type list

![Alt text](%20images/image-20221006103114090.png)

4、自定义列：提取最新两次交易时间

注意观察订单时间的排序，最新的在最前面

List.FirstN（列表名，行的数量）：返回列表中的前N行，得到一个新列

List.LastN（列表名，行的数量）：返回列表中的后N行，得到一个新列

![Alt text](%20images/image-20221006104944604.png)

5、自定义列：统计交易时间数量

部分客户是新的，要统计，然后剔除掉1

List.Count(列名)：返回计算列表中的元素个数

![Alt text](%20images/image-20221006105403066.png)

6、计算时间间隔

List.Max（列）：返回列表中最大的值

List.Min（列）：返回列表中最小的值

默认返回天数，且从0开始表示1天之内

![Alt text](%20images/image-20221006110157068.png)

——此方式计算过于片面，即不是按24小时进行换算的，故

Duration.Days（日期）：返回日期的天数，按小时进行换算，返回一个天数值

Number.Round（数值）：四舍五入，取整

![Alt text](%20images/image-20221006110731633.png)

7、寻找关键值：8020法则

20%的客户集中在前80%的时间间隔内或80%的客户集中在20%的关键时间间隔内

![Alt text](%20images/image-20221006111223571.png)

8、时间排序，关闭并上载

间隔时间升序下，间隔越近，说明该间隔内的客户价值越高

![Alt text](%20images/image-20221006111257335.png)

9、计算时间间隔的累计占比

累计占比 = SUMX(FILTER('客户生命周期表',EARLIER('客户生命周期表'[最近两次交易时间间隔])>=[最近两次交易时间间隔]),[计数])/SUM('客户生命周期表'[计数])

![Alt text](%20images/image-20221006112313615.png)

10、可视化

![Alt text](%20images/image-20221006112603362.png)

 

分析结论：

\>时间间隔在13天，人数的累计占比超80%，说明这个数据集中客户生命周期在这13天内，经营者应在13天内对客户进行有效的激活策略（催单、回访、促销活动通知等），通过拐点可以细化通知时间，但至少13天内必须进行一次

 

\### 客户价值分组---RFM模型

 

RFM模型：衡量客户价值和创利能力的重要手段和工具，CRM（客户关系管理系统）中经常被使用

\>R：最近一次消费时间间隔

F：消费的频率

M：消费的金额

——对于R、F两个指标随着公司业务的不同以及计算手段的不同，其含义可变；但M一般都是指金额

 

\#### 计算R

 

计算现在与最近一次购买时间之间的间隔天数

\>离现在的间隔越小，说明该客户价值越高

新建列：天数的时间间隔 =DATEDIFF([订单付款时间],TODAY(),DAY)

新建度量值：R = MIN([天数的时间间隔])

 

\#### 计算F

 

对下单的订单数量进行统计

\>订单数量越大，该客户价值越高

F = COUNTA([订单编号])

 

\#### 计算M

 

对销售金额进行统计

\>消费金额越高，该客户价值越高

M = SUM([买家实际支付金额])

 

需求：

\>利用dax函数按买家会员名将R、F、M进行汇总，形成一张新表正式用于分析

 

步骤：

\>新建表：RFM = SUMMARIZE('订单表',[买家会员名],"R",[R],"F",[F],"M",[M])

 

根据RFM定义，大于均值的标为“+”，小于均值的标为“-” ，共有8中组合——本项目中R求的是时间间隔，故其判断上应该 小于均值越有价值

![Alt text](%20images/image-20221006140203455.png)

\>![Alt text](%20images/image-20221006140552186.png)

客户价值 = IF('RFM'[R]<AVERAGE(RFM[R])&&'RFM'[F]>AVERAGE(RFM[F])&&'RFM'[M]>AVERAGE(RFM[M]),"重要价值客户",IF('RFM'[R]<AVERAGE(RFM[R])&&'RFM'[F]>AVERAGE(RFM[F])&&'RFM'[M]<AVERAGE(RFM[M]),"一般价值客户",IF('RFM'[R]>AVERAGE(RFM[R])&&'RFM'[F]>AVERAGE(RFM[F])&&'RFM'[M]>AVERAGE(RFM[M]),"重要保持客户",IF('RFM'[R]>AVERAGE(RFM[R])&&'RFM'[F]>AVERAGE(RFM[F])&&'RFM'[M]<AVERAGE(RFM[M]),"一般保持客户",IF('RFM'[R]<AVERAGE(RFM[R])&&'RFM'[F]<AVERAGE(RFM[F])&&'RFM'[M]>AVERAGE(RFM[M]),"重要发展客户",IF('RFM'[R]<AVERAGE(RFM[R])&&'RFM'[F]<AVERAGE(RFM[F])&&'RFM'[M]<AVERAGE(RFM[M]),"一般发展客户",IF('RFM'[R]>AVERAGE(RFM[R])&&'RFM'[F]<AVERAGE(RFM[F])&&'RFM'[M]>AVERAGE(RFM[M]),"重要挽留客户","一般挽留客户")))))))

 

不同标签的客户有不同的对应策略（常规）：

 

\- 重要价值：消费时间近，消费次数高，金额高，属于VIP客户，必须重点关注，跟踪他们的消费行为，及时提供高质量服务

\- 重要保持：消费时间远，消费次数高，金额高，可能是一段时间没来的忠诚客户，可以主动保持联系

\- 重要发展：消费时间近，消费次数不高，金额高，可能是一些新客户或潜力客户，必须重点发展

\- 重要挽留：消费时间远，消费次数不高，金额高，可能是快要流失或已经流失的客户，必须采取挽留措施

\- 另外4种组合与上类似，以一般定义，其重要程度低于【重要】

 

可视化：

![Alt text](%20images/image-20221006141615393.png)

 

补充：

若有客户信息，可以做的分析方向：

 

\- 客户特征分析

\- 客户用户画像

\- 客户用户行为等

——比如客户特征分析，可以分析一些客户的购买特征（高价值客户喜欢移动端下单，还是网页端下单；直接付款还是会有下单后有间隔付款等。

——以及配合用户画像找到用户的年龄特征、地区特征、消费水平等；得到结论后即可对后续开展新用户或维护一些老用户的时候找到趋向该特征的人群进行加大的服务等）

 

==练习：【抖音bi分析项目】==

 

\# 三、Tableau

 

\## 1、tableau基础操作

 

public【社区版】下载---https://www.tableau.com/products/public/download

 

desktop和public版本区别

\>1、public不支持数据的服务连接

2、desktop可以直接将项目另存为到本地

——public只能先上载到网页端后再从网页端下载到本地，并且上次必须有登陆账号（私人邮箱注册）

3、保存类型

twb：压缩版，只保存可视化内容，不包含数据本身，当打开文件需要有访问权来创建该文件的一些数据库

twbx：项目文件，包含了可视化可数据信息，

——但该文件有版本要求，低版本打不开高版本的，

——desktop和public的保存文件之间也不互通，故一般公司进行项目合作或团队合作的话，其软件版本必须保持一致；

——同时public网页端下载下来的默认为该文件类型

 

\### 数据导入界面

 

![Alt text](%20images/image-20221006150733784.png)

 

\### 可视化制作界面

 

![Alt text](%20images/image-20221006152338311.png)

 

\### 排序功能

 

\>1、数据预览区

快速了解数值的取值范围以及是否有重复值内容

![Alt text](%20images/image-20221006152726975.png)

2、工具栏中

3、图表字段上

![Alt text](%20images/image-20221006153210652.png)

4、行列字段（自定义）

![Alt text](%20images/image-20221006153608693.png)

5、纯手动拖拽

![Alt text](%20images/image-20221006154157163.png)

 

\### 分层

 

分层（主针对字段列表中的维度字段）

需求：

\>对几个变量创建一个分层结构，以便在制图或数据分析时随时向下钻取数据。在【维度】列表中，我们就可以对相应的字段创建分层结构。

 

操作：

\>选择一个目标字段---右击---分层结构---创建【结构名称】---依次拖入其他层级内容---展开

钻取：双击字段名称（注意不是双击图形），可ctrl+z撤销操作

![Alt text](%20images/image-20221006160626575.png)

 

\### 分组

 

分组（主针对图表中的字段）

需求：

\>当做好图后，可能存在某些数值很小，而且对分析也没有重要影响的变量值，为避免注意力分散，可以将这些数值很小的变量值归到一个组里，更利于分析

 

步骤：

\>ctrl多选多个字段---右键【分组】---右键【编辑别名】

选中字段---右击---编辑组/取消分组

![Alt text](%20images/image-20221006161727111.png)

 

\### 创建集

 

创建集（主针对度量值 --- 图表中的图形）

需求：

\>得到负利润产品的对比展示

 

步骤：

\>1、通过查看产品子类别的利润情况，得到负利润的展示

CTRL选中所有负利润的矩形 --- 右击 --- 创建集 --- 修改集名称，确定

![Alt text](%20images/image-20221006162625278.png)

2、该字段拥有正常字段的操作功能，比如筛选、修改颜色、大小等

——将集拖拽到标记【颜色】，修改颜色

3、进阶：数据量大时，用逻辑判断，if判断利润<0 的来筛选中符合条件的字段

 

\### public保存方式

 

\>1、保存到public

2、登录账号

3、修改文件名称

4、耐心，会自动跳转网页端（不行则重新保存）

5、页面右上角进行下载（工作簿），选当前版本

 

\### 参数

 

概念：

\>在制作可视化图表的过程中，我们有时需要构造一个新的参数来帮助分析，这个参数本质是没有任何意义的，其参数值一般不会是具体的固定的值；也可以用在筛选过滤上等等

 

步骤：

\>![Alt text](%20images/image-20221007094428673.png)

销售额增长参数

![Alt text](%20images/image-20221007094648769.png)

允许的值：

1、全部 --- 从1~正无穷大；

2、列表---给定几个值，从这些值中进行挑选；

3、范围--- 给到最大最小值和增量

 

\## 2.主要功能函数

 

创建计算字段

 

\### 聚合函数

 

SUM

利润率：SUM([利润]/[销售额])

COUNT

不同产品子类别的订单数量：COUNT([订单号])

 

\### 时间函数

 

DATEDIFF（时间单位，开始时间，结束时间）

订单反应时间：DATEDIFF("day",[日期],[运送日期])

\>——需求：最大订单反应时间

聚合方式改为最大值，展示数据标签

![Alt text](%20images/image-20221007101027818.png)

 

补充：修改值聚合方式

![Alt text](%20images/image-20221007100554467.png)

 

\### 逻辑函数

 

IF——类似编程语法，后面没有括号，语法之间用空格隔开

\>if 条件1 then 结果1

——[ else if 条件2 then 结果2

——....

——eles 默认结果 ]

end

 

需求：

\>计算家具产品的毛利润率（利润-运输成本），其余产品正常返回利润值，计算其利润率

 

步骤：

\>![Alt text](%20images/image-20221007101816352.png)

 

补充：修改字段值的百分比格式

![Alt text](%20images/image-20221007102739009.png)

 

\### 在公式中嵌套函数

 

需求：

\>根据去年的销售情况分析得到：销售额的增长规律为百分之一到百分之三之间，但具体不固定，

——现想了解明年这个时间的销售额金额增长后的金额值是多少？将其作为目标值

 

步骤：

\>1、创建参数

![Alt text](%20images/image-20221007104718231.png)

2、创建计算字段（增长率的换算 ---除以100）

![Alt text](%20images/image-20221007104851888.png)

3、可视化

![Alt text](%20images/image-20221007105156699.png)

4、取值调整：参数字段---右键【显示参数】---1-3

![Alt text](%20images/image-20221007105246013.png)

5、控件修改：

拖拽字段到筛选器，右键【显示筛选器】==切片器

切片器方式：下拉列表、勾选等等

![Alt text](%20images/image-20221007105944409.png)

 

\## 3、快速表计算

 

​    部分常用的分析不需要用公式来实现，可通过快速表计算，比如汇总、累计、百分差异、同比增长等。（函数模块化）

分析方法计算：

\>通过编辑表计算或添加表计算可以对该度量值进行更复杂的操作和设置

![Alt text](%20images/image-20221007105944409.png)

 

最常规的聚合计算：

\>![Alt text](%20images/image-20221007105944409.png)

 

\## 4、常见可视化对象

 

\### 地图

 

需求：想知道不同省份的销售金额和利润情况

![Alt text](%20images/image-20221007112114386.png)

 

\### 复合图（组合图）

 

需求：分析该公司近几年各个区域的销售情况

![Alt text](%20images/image-20221007134405480.png)

 

\### 嵌套条形图

 

需求：得到2009年的销售额

![Alt text](%20images/image-20221007141420693.png)

 

\### 动态图

 

需求：动态的观察某公司在这几年内，销量和利润的变化情况，并对比销量和利润的变化趋势

![Alt text](%20images/image-20221007143147524.png)

 

\### 热图

 

需求：分析该公司三大产品中哪类产品在全国哪个省的销售额或利润是最大的

![Alt text](%20images/image-20221007145336653.png)

 

\### 瀑布图（甘特图）

 

需求：观察某公司各个产品子类别的利润累积情况

![Alt text](%20images/image-20221007150816218.png)

 

\### 帕累托图

 

需求：分析是否是80%的利润额来源于20%的大客户

![Alt text](%20images/image-20221007152941237.png)

 

\### 文字云（词云）

 

需求：分析各类产品的销售情况

![Alt text](%20images/image-20221007160723986.png)

 

\### 散点图

 

需求：分析各类产品的销售额和运送到目的地的费用情况

![Alt text](%20images/image-20221007163033538.png)

 

\### 子弹图

 

需求：分析各类咖啡及其它饮品的实际销售额是否达到了预定目标

![Alt text](%20images/image-20221008100134516.png)

 

\## 5、设计动态仪表板

 

\### 设计排版

 

需求：

\>在此仪表板中放一个区域切片器和产品切片器（筛选器），并且为仪表板添加标题：销售分析

 

切片器展示：

\>方式一：回到单独的工作表中，添加筛选器，右击---显示筛选器，同时利用右上角小三角调整其样式；然后回到仪表板中重新拖入该图形，进行再次排版

![Alt text](%20images/image-20221008102128039.png)

方式二：直接在仪表板中，选择相应的图形（必须有应用到该字段），点击图形边缘位置的小三角【更多选项】---筛选器

![Alt text](%20images/image-20221008102353221.png)

 

\### 添加联动性

 

【仪表板】操作 --- 筛选

![Alt text](%20images/image-20221008103439638.png)

 

\### 切片器联动

 

![Alt text](%20images/image-20221008103851851.png)

 

\### 故事

 

![Alt text](%20images/image-20221008105725850.png)

 

\### 个性化背景

 

菜单栏【地图】--背景图像---插入图片

![Alt text](%20images/image-20221008110856936.png)

取值范围观察数值坐标，尽量比其大一点点，不要过于贴边【建议直接到源数据上利用排序，观察下最大最小值】

 

\## 6、分析案例

 

\### 货架分析

 

\### 保险公司经营分析

 

\### 网络广告投放分析

 

\# 四、MySQL基础

 

\## 语言分类

 

\>1、DDL （数据定义语言）Data Definition Language：定义、修改、删除数据库内部结构，建表建库

2、DML （数据处理语言）Data Manipulation Language：在数据表中进行更新、增加和删除记录，录入修改增减数据内容

3、DQL （数据查询语言）Data Query Language：select查询语句（分析师所需，数据库的重点，重中之重）

4、DCL （数据控制语言）Data Control Language：数据权限，用于设置用户权限和控制事物语句（了解）

 

\## 1、DDL建表建库

 

\>1、登录服务器：mysql -u root -p

2、展示数据库：show databases;

3、创建数据库：create database 数据库名称;

4、使用数据库：use 数据库名;

5、删除数据库：drop database 数据库名;

6、重命名数据库：rename 数据库名;

7、建表：create table 表名 (字段N[列名] 字段类型[数据类型] 可选字段约束 默认值);

 

 

驼峰式命名法则：

 

\- ShangHai（正确，大驼峰）

\- shangHai（正确，小驼峰）

\- shang_hai（正确，带下划线）

\- shanghai（正确，但规范上不属于驼峰写法）

\- shang hai（错误，有空格，mysql无法区分）

 

\## 2、数据类型

 

\>1、整数：int

![Alt text](%20images/image-20221010111544957.png)

2、浮点数：float

3、英文：char(255)

4、中文：varchar(255)

![Alt text](%20images/image-20221010112021737.png)

5、日期：date

![Alt text](%20images/image-20221010112136295.png)

6、空值：null![Alt text](%20images/1684830095428.png)

 

\## 3、约束

 

![Alt text](%20images/image-20221010112641738.png)

\>1、not null：新增数据时，这个字段必须有值

2、default：在没有给定值的时候，数据库默认的值

3、unique key（UK）：唯一是指一个字段中的所有值不能重复

4、primary key（PK）：主键，通过主键一定能找到唯一的一条记录（主键包含了非空且唯一两种约束）

5、auto_increment：当我们需要主键自动增长的时候可以使用自动增长的约束。

——注意：自动增长的约束必须是主键且数据类型为int，不会回退

6、forming key（FK）：外键约束，比如学生表中的地址字段的取值范围是由 地址表的主键来约束的

——注意：子表的取值范围受父表的控制，先有父表、再建子表

 

\## 4、常见操作

 

\>1、查看表结构：desc 表名;

2、查看建表语句(外键)：show create table 表名;

3、查看库中所有表：show tables;

4、修改表名：alter table 旧表名 rename to 新表名;

5、修改字段名：alter table 表名 change 旧字段名 新字段名 新数据类型;

6、删除字段：alter table 表名 drop 字段名;

7、删除表：drop table 表名;

8、删除外键关系：alter table 表名 drop foreign key 外键名;

 

\## 5、DBeaver使用

 

\>说明

![Alt text](%20images/image-20220825153158903.png)

父子表

![Alt text](%20images/image-20221010155128802.png)

新建列

![Alt text](%20images/image-20221010155843029.png)

新建内主键约束

![Alt text](%20images/image-20220825160214624.png)

新建外键：修改外键名，保存ctrl+S

![Alt text](%20images/image-20220825160840041.png)

 

\## 6、导入导出

 

导出

\>1、cmd：mysqldump -h 主机所在IP -u 用户名 -p 要导出的数据库名 > 导出的路径//自定义文件夹名.sql;

2、数据库上右击---工具---转储数据库---选择对应数据库和数据表

![Alt text](%20images/image-20220825162829160.png)

 

导入

\>1、use 数据库名;------source 所在路径://xxx.sql

2、新建一个数据库后---右击---工具---执行脚本

 

DBeaver不支持excel文件，支持csv

 

\## 7、DML增删改

 

INSERT --- 插入

 

\>1、insert into 表名 values (值1,值2,值3....), (值1,值2,值3....);

2、insert into 表名 (字段1,字段2,...) values (值1,值2,...), (值1,值2,...);

3、insert into 表名 set 字段1 = 值1,字段2 = 值2,字段3 = 值3....;

 

DELETE --- 删除

 

\>1、delete from 表名 where 字段名 = 值

2、truncate table 表名

 

UPDATE --- 更新

 

\>1、update 表名 set 列名1 = 新值1 ,列名2 = 新值2 where 列名 = 某值;

 

SELECT --- 查询

\>1、select 字段名1 as xxx,字段名2 as yyy from 表名;

2、select distinct 字段名 from 表名;

 

\## 8、条件限制查询

 

select 列字段 from 表名 where 列 运算符 值 [条件]

 

\### 关系/逻辑运算符

 

关系：大于、小于、等于、不等于!=(<>)、

逻辑：and（&&）、or（||）、xor异或、not（!）

 

\### BETWEEN AND

 

select 列字段 from 表名 where 字段 between 值1 and 值2;

 

\### IS NULL

 

select 列字段 from 表名 where 字段 is null;

 

\### IN条件

 

select 字段 from 表  where 字段 in (值1,值2,值3...);

 

\### LIKE匹配

 

select 列字段 from 表名 where 字段 like '_xx%';

 

\- _ 表示 一个字符数

\- % 表示0个或多个字符数

 

\## 9、排序查询

 

select 字段列 from 表名 [where 条件] order by 排序字段 asc|desc;

 

\## 10、分页查询

 

select 字段列 from 表名 [where 条件 order by 排序字段 asc|desc] limit N;

select 字段列 from 表名 [where 条件 order by 排序字段 asc|desc] limit 开始位置，行数;

 

\## 11、聚合函数

 

COUNT()函数：统计记录数；

——count（*）行统计， count(字段)非空计数

AVG()函数：求平均值；

SUM()函数：求和；

MAX()函数：求最大数；

MIN()函数：求最小数；

 

\## 12、分组查询

 

select 字段 from 表名 [where 筛选条件] group by 分组依据1,2 [order by 排序依据];

 

\## 13、HAVING筛选

 

where 的筛选是在分组之前，HAVING的筛选是在分组之后group by

 

\### ==执行顺序==

 

SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5

FROM player JOIN team ON player.team_id = team.team_id # 顺序 1

WHERE height > 1.80 # 顺序 2

GROUP BY player.team_id # 顺序 3

HAVING num > 2 # 顺序 4

ORDER BY num DESC # 顺序 6

LIMIT 2 # 顺序 7

 

\## 14、单表搜索函数case when

 

\>方式一：

case 字段

——when 值1 then 结果1

——when 值2 then 结果2

——when 值3 then 结果3

——...

——else 默认结果

end as 别名

from 表名

\>方式二：

case

——when 字段 逻辑符号 条件1 then 结果1

——when 字段 逻辑符号 条件2 then 结果2

——when 字段 逻辑符号 条件3 then 结果3

——....

——else 默认结果

end as 别名

from 表名

 

其中，【表名】部分常常是子查询的结果并给予别名（作为临时表）后的结果

 

\## 15、多表连接

 

\### 内连接

 

select 字段列 from 表1 inner join 表2 on 连接依据 (表1.字段 = 表2.字段)

 

select 字段列 from 表1 inner join 表2 on 表1.字段=表2.字段 inner join 表3 on 表1.字段=表3.字段

 

select 字段列 from 表1 inner join 表2 inner join 表3 on 表1.字段=表2.字段 and 表1.字段=表3.字段

 

select 字段列 from 表1 ,表2 ,表3 where 表1.字段=表2.字段 and 表1.字段=表3.字段

 

\### 外连接

 

左外连接：select 字段列 from 表1 left join 表2  on 连接依据

右外连接：select 字段列 from 表1 right join 表2  on 连接依据

 

\### 复合条件连接

 

1、单行单列：select * from  表1 where 字段名 > (select 字段名 from 表2 where 筛选条件)

 

2、单行多列：select * from  表1 where (字段名1，字段名2) = (select 字段名1，字段名2 from 表2 where 筛选条件)

 

3、带in的：select * from 表1 where 字段 in (select 子查询)

 

4、带exists的：select 字段列 from 表 where exists (子查询)

 

5、带all的：select * from 商品表1 where 单价 >all (select 单价 from 商品表1 where 分类名='洗衣机')

 

6、带any的：select * from 商品表1 where 单价 >any (select 单价 from 商品表1 where 分类名='洗衣机') and 分类名!='洗衣机'

 

7、not in 和 not exists

 

\## 16、合并查询

 

左右外连接+union （去重）

\>select a.*,b.* from  test_a a left join test_b b on a.id = b.id

union

select a.*,b.* from  test_a a right join test_b b on a.id = b.id

 

左右外连接+union all （不去重）

\>select a.*,b.* from  test_a a left join test_b b on a.id = b.id

union all

select a.*,b.* from  test_a a right join test_b b on a.id = b.id

 

\## 17、正则查询

 

regexp关键字

select 字符列 form 表名 where 字段名 regexp '匹配方式'

![Alt text](%20images/image-20221013151035613.png)

 

正则模式

\>1、^ [shift+6] :匹配特定字符串或字符打头的记录  ---  张姓打头的 ^张

2、$ [shift+4] : 匹配特定字符串或字符结尾的记录 --- 张字结尾的  张$

3、. :匹配字符串中的任一一个字符，包括回车和换行 --- 带有张字所有内容  张.

4、[S1S2S3...]:字符合集，匹配的所包含的任一个字符  --- 带有张或章字的内容  [张章]

5、[^...] ：匹配不包含在集合中的内容 --- 不带带有张或章字的内容 [^张章]

6、S1|S2|S3：匹配S1或S2或S3中的任意一个 --- 匹配张三或李四或王五  张三|李四|王五

7、* :匹配多个该字符之前的字符，包括0次或多次 --- 张字出现多次或没有出现的字符 张*

8、+:匹配多个该符号之前的字符，包括1个或多个 ---- 张字至少出现一次的字符 张+

9、{N}：匹配字符串出现N次  ----- 数字出现十次 [0-9]{10}

10、{N,M}：匹配字符串最少出现N次，最多出现M次  ---- ----数字至少出现5次，最多15个长度  [0-9]{5,15}

11、[0-9]：匹配数字内

12、[a-z]:匹配小写字母

13、[A-Z] :匹配大写字母

14、[A-Za-z0-9]:匹配数字或大小写英文

 

更多了解：https://www.runoob.com/regexp/regexp-syntax.html

 

\# 五、MYSQL进阶

 

\## 执行顺序













































# 五、MYSQL进阶

## 1、执行顺序

> 1、FROM
> 2、JOIN
> 3、ON
> 4、WHERE
> 5、GROUP	BY
> 6、聚合函数SUM\AVG...
> 7、HAVING
> 8、SELECT
> 9、DISTINCT
> 10、ORDER	BY
> 11、LIMIT

## 2、案例理解

### 需求

​	**t表**存储了每个商品类别的成交明细，我们需要通过下面这张表获取 **订单量大于10个对应的商品类别** ，并从中取出**订单量排名前2**的商品类别，还需要过滤掉表中的测试订单（cartid='c666'）。

### 数据源

​	构建t表

```mysql
CREATE TABLE `t`  (
  `orderid` int(0) NULL DEFAULT NULL,
  `cartid` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `name` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL
) 
ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- orderid：代表订单编号
-- cartid：代表商品类别编号，比如c1代表手机，c2代表牛奶
-- name：代表商品的名称
```

​	添加数据

```mysql
INSERT INTO `t` VALUES (1, 'c1', '手机');
INSERT INTO `t` VALUES (2, 'c2', '牛奶');
INSERT INTO `t` VALUES (1, 'c3', '大米');
INSERT INTO `t` VALUES (20, 'c1', '手机');
INSERT INTO `t` VALUES (3, 'c4', '冰箱');
INSERT INTO `t` VALUES (5, 'c666', '测试');
INSERT INTO `t` VALUES (1, 'c1', '手机');
INSERT INTO `t` VALUES (2, 'c1', '手机');
INSERT INTO `t` VALUES (3, 'c2', '牛奶');
INSERT INTO `t` VALUES (4, 'c3', '大米');
INSERT INTO `t` VALUES (5, 'c1', '手机');
INSERT INTO `t` VALUES (6, 'c2', '牛奶');
INSERT INTO `t` VALUES (7, 'c1', '手机');
INSERT INTO `t` VALUES (8, 'c1', '手机');
INSERT INTO `t` VALUES (9, 'c1', '手机');
INSERT INTO `t` VALUES (2, 'c1', '手机');
INSERT INTO `t` VALUES (1, 'c1', '手机');
INSERT INTO `t` VALUES (1, 'c3', '大米');
INSERT INTO `t` VALUES (1, 'c3', '大米');
INSERT INTO `t` VALUES (1, 'c2', '牛奶');
INSERT INTO `t` VALUES (1, 'c1', '手机');
INSERT INTO `t` VALUES (1, 'c3', '大米');
INSERT INTO `t` VALUES (2, 'c3', '大米');
INSERT INTO `t` VALUES (3, 'c3', '大米');
INSERT INTO `t` VALUES (4, 'c3', '大米');
INSERT INTO `t` VALUES (5, 'c3', '大米');
INSERT INTO `t` VALUES (6, 'c3', '大米');
INSERT INTO `t` VALUES (7, 'c3', '大米');
INSERT INTO `t` VALUES (5, 'c1', '手机');
INSERT INTO `t` VALUES (1, 'c4', '冰箱');
INSERT INTO `t` VALUES (2, 'c4', '冰箱');
INSERT INTO `t` VALUES (3, 'c4', '冰箱');
INSERT INTO `t` VALUES (4, 'c4', '冰箱');
INSERT INTO `t` VALUES (5, 'c4', '冰箱');
INSERT INTO `t` VALUES (6, 'c4', '冰箱');
INSERT INTO `t` VALUES (7, 'c4', '冰箱');
INSERT INTO `t` VALUES (8, 'c4', '冰箱');
INSERT INTO `t` VALUES (1, 'c4', '冰箱');
INSERT INTO `t` VALUES (1, 'c4', '冰箱');
INSERT INTO `t` VALUES (2, 'c4', '冰箱');
INSERT INTO `t` VALUES (3, 'c4', '冰箱');
INSERT INTO `t` VALUES (4, 'c4', '冰箱');
INSERT INTO `t` VALUES (5, 'c4', '冰箱');
INSERT INTO `t` VALUES (6, 'c4', '冰箱');
INSERT INTO `t` VALUES (7, 'c4', '冰箱');
```

### 取数

1、获取全部数据

```mysql
select * from t;
```

2、获取条件数据

​	过滤测试订单

```mysql
select cartid from t where cartid !='c666' group by cartid;
```

3、获取部分字段

​	订单量大于10

```mysql
select cartid,count(orderid) from t where cartid !='c666' group by cartid having count(orderid)>10;
```

4、获取排序数据

​	订单量前二的商品类别

```mysql
select cartid,count(orderid) from t where cartid !='c666' group by cartid having count(orderid)>10 order by count(orderid) desc limit 2;
```

### 分析

（1）首先需要知道到哪里查找我们需要的数据，所以第一个执行的应该是from部分；

（2）知道到哪张表提取数据以后，是否要提取这张表的全部数据呢？不是的，我们需要把一些测试订单过滤掉，当然了也可能是一些别的条件，这个时候就需要执行where部分了；

（3）因为我们筛选出来的是orderid维度的明细数据，但是我们需要的是cartid维度的数据，cartid与orderid的关系是一个cartid可能对应多个orderid，我们需要根据cartid去进行聚合，然后看每个cartid对应的订单数，这个过程其实就是在执行group by部分；

（4）group by聚合得到的结果是每个cartid对应的订单数，但是我们并不需要全部的cartid，所以我们需要对聚合后的结果进行过滤，筛选出订单数大于10个的cartid，这个过程其实是在执行having部分；

（5）执行完having以后，我们就得到了订单数大于10个的cartid，这个时候我们可以利用select把cartid等数据查询出来；

（6）这样查询出来的数据是订单数大于10个的全部cartid，但是我们其实最终想要的是订单数大于10个中的前三个catid，就需要对cartid根据订单数进行降序处理，这个过程是在执行order by部分;

（7）降序完成以后，我们只需要前2个cartid，通过limit限制一下显示的行数就可以了，这个过程执行的是limit部分。

### 注意group by

（1）group by必须声明在from后面，where后面，order by前面，limit前面。

（2）group by分组后需要进行条件筛选的话必须使用having关键字进行条件筛选，不能使用where（分组前使用where，分组后使用having）

（3）where后的条件表达式里不允许使用聚合函数，而having可以。

（4）当一个查询语句同时出现where、group by、having、order by、limit的时候，执行顺序和编写顺序是：

> 第一：执行where语句对全表进行做筛选，返回第1个结果集。
> 第二：执行第1个结果集使用group by进行分组，返回第2个结果集（分组过后的结果集）。
> 第三：针对第2个结果集中每一组数据进行前面的select语句操作，有几组就执行几次，返回第3个结果集。
> 第四：针对第3个结果集执行having语句进行筛选，返回分组过后的第4个结果集。
> 第五：针对第4个结果集进行order by排序，返回第5个结果集。
> 第六：针对第5个结果集进行limit分页操作，返回第6个结果集。

（5）当group by后有多个字段进行分组时，相当于当成一个整体的字段进行分组

（6）除了聚合函数语句外，select中每个列都必须在group by分组中出现，否则会报only_full_group_by错误。（简述报错的原因）

> 报错信息解释：要确保group by条件有且只有唯一确定的字段，select字段里面包含了没有被group by条件唯一的字段，因为执行group by语句实际上将同一组内多行记录合并成一行，同一个字段对应的值并不同，那搜索引擎不知道该 返回哪一条，违背了only_full_group_by原则，所以系统报错。

## 3、代码规范

### 代码缩进

关键词要位于每行代码的最开始位置，关键词后面的内容尽量单独起一行，非查询关键词的内容缩进四个空格。

```mysql
select 
	cartid,
	count(orderid) as 类别订单的数量 
from 
	t 
where 
	cartid !='c666' 
group by 
	cartid 
having 
	类别订单的数量>10 
order by 
	类别订单的数量 desc 
limit 2;
```

### 逗号位置

列名与列名之间的逗号要放在前面，如果放在后面，不易被发现，会导致经常出现多写或少写逗号的错误。

```mysql
select
    col1
    ,col2
    ,col3
from
    table;
```

### 注释

多行内容，用/**/注释符。单行内容，用-- 注释符。

```mysql
/*
这是全国每个城市每天的订单明细表, 
如果要获取特定城市的订单明细表, 只需要输入city_id即可, 
如果要获取特定日期的订单明细表, 输入具体日期范围即可
*/

select
    col1 -- 销售人员ID
    col2, -- 销售人员姓名
    col3, -- 销售人员级别
from
    table;
```

## 4、Case表达式

### 语法

```mysql
-- 简单 CASE 表达式：
CASE sex
	WHEN  ' 1 ' THEN  ' 男 '
	WHEN  ' 2 ' THEN  ' 女 '
	ELSE  ' 其他 ' 
END

-- 搜索 CASE 表达式（常用）：
CASE 
	WHEN sex =  ' 1 ' THEN  ' 男 '
	WHEN sex =  ' 2 ' THEN  ' 女 '
	ELSE  ' 其他 ' 
END
```

### 注意事项

（1）注意事项 1：统一各分支返回的数据类型

​	一定要注意 CASE 表达式里各个分支返回的数据类型是否一致。某个分支返回字符型，而其他分支返回数值型的写法是不正确的。

（2）注意事项 2：不要忘了写 END

​	虽然忘记写end时程序会返回比较容易理解的错误消息，不算多么致命的错误。但是，感觉自己写得没问题，而执行时却出错的情况大多是由这个原因引起的。

（3）注意事项 3：养成写 ELSE 子句的习惯

​	ELSE 子句是可选的，不写也不会出错。不写 ELSE 子句时，CASE 表达式的执行结果是 NULL 。

​	但是不写可能会造成 “语法没有错误，结果却不对“ 这种不易追查原因的麻烦，所以最好明确地写上 ELSE 子句（即便是在结果可以为 NULL 的情况下）。

### Case实战一：统计性别

​	进行不同条件的统计是 CASE 表达式的著名用法之一，也是行转列的较经典应用。

#### 需求

​	需要往存储各县人口数量的表 PopTbl2 里添加上“性别”列，然后求按性别、县名汇总的人数。具体来说，就是统计表 PopTbl2 中的数据，然后求出如表“统计结果”所示的结果。

![1684923343778](C:\Users\6868668\AppData\Local\Temp\1684923343778.png)

#### 数据源

构建PopTbl2表

```mysql
CREATE TABLE PopTbl2(
    pref_name VARCHAR(32),
 	sex CHAR(1) NOT NULL,
 	population INTEGER NOT NULL,
	PRIMARY KEY(pref_name, sex)
);
```

添加数据

```mysql
INSERT INTO PopTbl2 VALUES('德岛', '1',	60 );
INSERT INTO PopTbl2 VALUES('德岛', '2',	40 );
INSERT INTO PopTbl2 VALUES('香川', '1',	100);
INSERT INTO PopTbl2 VALUES('香川', '2',	100);
INSERT INTO PopTbl2 VALUES('爱媛', '1',	100);
INSERT INTO PopTbl2 VALUES('爱媛', '2',	50 );
INSERT INTO PopTbl2 VALUES('高知', '1',	100);
INSERT INTO PopTbl2 VALUES('高知', '2',	100);
INSERT INTO PopTbl2 VALUES('福冈', '1',	100);
INSERT INTO PopTbl2 VALUES('福冈', '2',	200);
INSERT INTO PopTbl2 VALUES('佐贺', '1',	20 );
INSERT INTO PopTbl2 VALUES('佐贺', '2',	80 );
INSERT INTO PopTbl2 VALUES('长崎', '1',	125);
INSERT INTO PopTbl2 VALUES('长崎', '2',	125);
INSERT INTO PopTbl2 VALUES('东京', '1',	250);
INSERT INTO PopTbl2 VALUES('东京', '2',	150);
```

#### 联表查询(非case)

A：分别统计每个城市的男性人口、女性人口

```mysql
-- 男性人口
select 
	pref_name,
	sum(population) as `男`
from 
	poptbl2
where 
	sex='1'
group by 
	pref_name;
	
-- 女性人口
select 
	pref_name,
	sum(population) as `女`
from 
	poptbl2
where 
	sex='2'
group by 
	pref_name;
```

B：横向拼接（inner join）

```mysql
select 
	a.pref_name as `县名`,
	a.`男`,
	b.`女`
from
	(	select	pref_name,	sum(population) as `男`
		from poptbl2
		where sex='1'
		group by pref_name
	)a
inner join
	(	select 	pref_name,	sum(population) as `女`
		from poptbl2
		where sex='2'
		group by pref_name
	)b
on 
	a.pref_name=b.pref_name;
```

#### Case实现一

A：使用case表达式来实现行列转置，给每个县匹配男和女这两个列

```mysql
-- 在统计男性人口数的时候按照population实际值，女性人口数为0
-- 在统计女性人口数的时候按照population实际值，男性人口数为0
select 
	pref_name as `县名`,
	case when sex='1' then population else 0 end as `男`,
	case when sex='2' then population else 0 end as `女`
from 
	poptbl2;
```

B：对pref_name进行分组操作，对每个城市的男性和女性进行人口统计

```mysql
select 
	t.`县名`,
	sum(t.`男`) as `男`,
	sum(t.`女`) as `女`
from
	(	select pref_name as `县名`,
			case when sex='1' then population else 0 end as `男`,
			case when sex='2' then population else 0 end as `女`
		from poptbl2
	)t
group by
	t.`县名`;
```

#### Case实现二

分析思路：

> 1、做一假设统计：即当我统计男性时，将女性的人数全部假设为0，当我统计女性时，全部将男性的人数假设为0
> 2、产生两个计算字段（boy，girl），遍历记录时，若当前的这一条记录是男性时，boy字段填充原值，girl字段填充0，若当前的这一条记录是女性时，boy字段填充0，girl字段填充原值。
>3、再对以上结果按pref_name分组求和，即得我们想要的结果

A：使用case表达式来实现行列转置，给每个县匹配男和女这两个列

```mysql
-- 在统计男性人口数的时候按照population实际值，女性人口数为0
-- 在统计女性人口数的时候按照population实际值，男性人口数为0
select 
	pref_name as `县名`,
	case when sex='1' then population else 0 end as `男`,
	case when sex='2' then population else 0 end as `女`
from 
	poptbl2;
```

B：直接对case表达式进行聚合计算

```mysql
select 
	pref_name as`县名`,
	sum(case when sex='1' then population else 0 end) as `男`,
	sum(case when sex='2' then population else 0 end) as `女`
from
	poptbl2
group by
	`县名`;
```

### Case实战二：统计课程表

​	新手用 WHERE 子句进行条件分支，高手用 SELECT 子句进行条件分支。

​	在 CASE 表达式里，我们可以使用 BETWEEN 、 LIKE 和 <、 > 等便利的谓词组合，以及能嵌套子查询的 IN 和 EXISTS 谓词。

#### 需求

​	有一张培训学校的课程一览表和一张管理每个月所设课程的表，要用这两张表来生成下面这样的交叉表，以便于一目了然地知道每个月开设的课程

![1684937309972](C:\Users\6868668\AppData\Local\Temp\1684937309972.png)

#### 数据源

构建CourseMaster表、OpenCourses表，并添加数据

```mysql
CREATE TABLE CourseMaster
	(course_id   INTEGER PRIMARY KEY,
 	course_name VARCHAR(32) NOT NULL);
 
INSERT INTO CourseMaster VALUES(1, '会计入门');
INSERT INTO CourseMaster VALUES(2, '财务知识');
INSERT INTO CourseMaster VALUES(3, '簿记考试');
INSERT INTO CourseMaster VALUES(4, '税务师');

CREATE TABLE OpenCourses
	(month       INTEGER ,
	course_id   INTEGER ,
	PRIMARY KEY(month, course_id));

INSERT INTO OpenCourses VALUES(200706, 1);
INSERT INTO OpenCourses VALUES(200706, 3);
INSERT INTO OpenCourses VALUES(200706, 4);
INSERT INTO OpenCourses VALUES(200707, 4);
INSERT INTO OpenCourses VALUES(200708, 2);
INSERT INTO OpenCourses VALUES(200708, 4);
```

#### Case实现一

​	使用Case 语句结合 In 谓词

A：查看每个月开设课程的编号

```mysql
select course_id from opencourses where month='200706'
select course_id from opencourses where month='200707'
select course_id from opencourses where month='200708'
```

B：查看每门课程每个月开设的情况，有开设使用O，没有开始使用X

```mysql
select 
	a.course_name `课程名称`,
	
	case when 
		a.course_id in(select course_id from opencourses where month='200706') then 'O' else 'X' 
	end as `6月`,
	
	case when 
		a.course_id in(select course_id from opencourses where month='200707') then 'O' else 'X' 
	end as `7月`,
	
	case when 
		a.course_id in(select course_id from opencourses where month='200708') then 'O' else 'X' 
	end as `8月`
from 
	coursemaster a;
```

#### Case实现二

​	exists用于判断子查询是否至少会返回一行数据，实际上并不会返回任何数据，返回的是true或false。

```mysql
select 
	a.course_name as `课程名称`,
	
	case when 
		exists(select course_id from opencourses b where month='200706' and b.course_id=a.course_id) then 'O' else 'X' 
	end as `6月`,
	
	case when 
		exists(select course_id from opencourses b where month='200707' and b.course_id=a.course_id) then 'O' else 'X' 
	end as `7月`,
	
	case when 
		exists(select course_id from opencourses b where month='200708' and b.course_id=a.course_id) then 'O' else 'X' 
	end as `8月`
from 
	coursemaster a;
```

### Case企业面试题一

#### 需求

​	统计查询每个日期比赛的场次和胜负场次

![1684938282601](C:\Users\6868668\AppData\Local\Temp\1684938282601.png)

#### 数据源

构建game表，并添加数据

```mysql
create table game(rq varchar(10),result char(1));

insert into game values('2005-05-09','胜');
insert into game values('2005-05-09','胜');
insert into game values('2005-05-09','负');
insert into game values('2005-05-09','负');
insert into game values('2005-05-10','胜');
insert into game values('2005-05-10','负');
insert into game values('2005-05-10','负');
```

#### SUM函数实现

A：统计每个日期下的比赛场次

```mysql
select 
	rq,
	count(*) as `场次`
from 
	game
group by
	rq;
```

B：统计每个日期下比赛的场次和胜负情况

```mysql
select 
	rq as `日期`,
	case when result='胜' then 1 else 0 end as `胜`,
	case when result='负' then 1 else 0 end as `负`
from 
	game;
```

C：给日期进行分组后统计白塞场次和输赢情况

```mysql
select 
	rq as `日期`,
	count(*) as `场次`,
	sum(case when result='胜' then 1 else 0 end) as `胜`,
	sum(case when result='负' then 1 else 0 end) as `负`
from 
	game;
```

#### COUNT函数实现

A：错误写法

```mysql
select 
	rq as `日期`,
	count(*) as `场次`,
	count(case when result='胜' then 1 else 0 end) as `胜`,
	count(case when result='负' then 1 else 0 end) as `负`
from 
	game
group by
	`日期`;
	
-- count聚合函数在使用的时候代表求记录条数的意思，如果碰到字段为NULL的时候就不会进行统计，如果碰到字段值为数值类型的包括0在内，它都会进行统计，所以根据时机情况而定，要么使用NULL要么使用0，在本案例当值只能使用NULL
```

B：正确写法

```mysql
select 
	rq as `日期`,
	count(*) as `场次`,
	count(case when result='胜' then 1 else null end) as `胜`,
	count(case when result='负' then 1 else null end) as `负`
from 
	game
group by
	`日期`;
```

### Case企业面试题二

#### 需求

​	统计需查每年每月的金额，amount为金额的意思

![1684939036234](C:\Users\6868668\AppData\Local\Temp\1684939036234.png)

#### 数据源

构建sale_table表，并添加数据

```mysql
create table sale_table(
	`year` int,
	`month` int,
	`amount` float
);

insert into sale_table values(1991,1,1.1),(1991,2,2.2),(1991,3,3.3);
insert into sale_table values(1992,1,2.1),(1992,2,3.2),(1992,3,4.3);
```

#### Case实现

```mysql
select
	year,
	round(sum(case when `month` =1 then amount else 0 end),1) as `m1`,
	round(sum(case when `month` =1 then amount else 0 end),1) as `m2`,
	round(sum(case when `month` =1 then amount else 0 end),1) as `m3`
from 
	sale_table
group by
	year;
```

## 5、数据去重

#### 什么是去重问题？

（1）数据表中存在着两条或两条以上一模一样的数据

（2）数据表中存在着除主键不同外其他均相同的两条或以上重复的数据

（3）数据表中的关键字段存在着两条及以上重复的数据

#### 数据源

构建student学生表

```mysql
DROP TABLE IF EXISTS `student`;
CREATE TABLE `student`  (
  `id` int(0) NOT NULL,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `cardNo` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `sex` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `age` int(0) NULL DEFAULT NULL,
  `address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) 
ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;
```

添加数据

```mysql
INSERT INTO `student` VALUES (1, '张三', '320923200011126785', '男', 23, '上海');
INSERT INTO `student` VALUES (2, '张三', '320923200011126785', '男', 23, '上海');
INSERT INTO `student` VALUES (3, '李四', '420923200011126733', '男', 24, '北京');
INSERT INTO `student` VALUES (4, '张三', '320923200011126785', '男', 23, '上海');
INSERT INTO `student` VALUES (5, '李四', '420923200011126733', '男', 24, '北京');
INSERT INTO `student` VALUES (6, '王五', '120923200011126321', '男', 25, '广州');
INSERT INTO `student` VALUES (7, '李四', '420923200011126733', '男', 24, '北京');
INSERT INTO `student` VALUES (8, '王五', '120923200011126321', '男', 25, '广州');
INSERT INTO `student` VALUES (9, '张三', '320923200011126785', '男', 23, '上海');
INSERT INTO `student` VALUES (10, '张三', '320923200011126785', '男', 23, '上海');
INSERT INTO `student` VALUES (11, '赵六', '220923200011126980', '男', 26, '深圳');
INSERT INTO `student` VALUES (12, '赵六', '220923200011126980', '男', 26, '深圳');
INSERT INTO `student` VALUES (13, '陈七', '520923200011126777', '女', 27, '重庆');
INSERT INTO `student` VALUES (14, '陈七', '520923200011126777', '女', 27, '重庆');
INSERT INTO `student` VALUES (15, '李八', '620923200011126888', '男', 28, '城都');
INSERT INTO `student` VALUES (16, '李八', '620923200011126888', '男', 28, '城都');
INSERT INTO `student` VALUES (17, '徐九', '720923200011126999', '男', 29, '苏州');
INSERT INTO `student` VALUES (18, '徐九', '720923200011126999', '男', 29, '苏州');
INSERT INTO `student` VALUES (19, '吴十', '820923200011121010', '男', 30, '无锡');
INSERT INTO `student` VALUES (20, '吴十', '820923200011121010', '男', 30, '无锡');
INSERT INTO `student` VALUES (21, '周迅', '111111111111111111', '女', 55, '衢州');
INSERT INTO `student` VALUES (22, '孙俪', '999999999999999999', '女', 45, '上海');
INSERT INTO `student` VALUES (23, '马丽', '630923200011126666', '女', 18, '常州');
INSERT INTO `student` VALUES (24, '马丽', '630923200011126666', '女', 18, '常州');
INSERT INTO `student` VALUES (25, '马丽', '630923200011126666', '女', 18, '常州');
INSERT INTO `student` VALUES (26, '马丽', '630923200011126666', '女', 18, '常州');
INSERT INTO `student` VALUES (27, '刘德华', '888888888888888888', '男', 60, '香港');
INSERT INTO `student` VALUES (28, '张学友', '666666666666666666', '男', 62, '香港');
INSERT INTO `student` VALUES (29, '郭富城', '555555555555555555', '男', 58, '香港');
INSERT INTO `student` VALUES (30, '黎明', '333333333333333333', '男', 61, '香港');
```

#### 实例演示

1）查询有没有重复的数据的记录数：判断name和cardNo字段一样的为重复数据，并统计重复次数

```MYSQL
select 
	name,
	cardNo,
	count(*) as `重复的记录数`
from 
	student
group by
	name,
	cardNo 
having 
	count(*)>1;
```

2）查询全部重复的数据（将学生所有的字段信息全部显示出来：不显示重复的记录数）

```MYSQL
select 
	a.*
from 
	student a
where 
	a.cardNo 
in	(
		select cardNo
		from student
		group by name,cardNo 
		having count(*)>1
	);
```

3）删除重复记录(以下写法是错误的，会报错)

错误写法

```MYSQL
delete
from 
	student a
where 
	a.cardNo 
in	(
		select cardNo
		from student
		group by name,cardNo 
		having count(*)>1
	);
-- 报错的信息：上面执行后报错信息意思为不能再进行查询操作的表上同时进行update和delete操作！
-- 原因解释：因为MySQL数据据拒绝此类危险的操作，由于这种操作很容易清空表中的数据，所以设计者考虑到此类情况直接拒绝此类危险操作！那又如何进行操作呢？
```

4）删除重复记录(以下写法语法是正确的，但是又有新的问题出现)

​	删除前建议做备份操作

A：备份操作

```MYSQL
create table student2 select * from student
select * from student2;
```

B：删除操作

```MYSQL
delete
from 
	student2 a
where 
	a.cardNo 
in	(
		select 
			t.cardNo
		from (
				select cardNo
				from student2
				group by name,cardNo 
				having count(*)>1
			)t
	);
-- 发现问题：student2表中只要出现重复的学生信息都被清空了，留下的都是唯一不重复的数据，但是我们想要的结果是保留唯一不重复的数据和重复数据中保留一条即可，哪有该怎么办呢？
```

5）查询表中多余重复的学生的信息（过滤编号id最小的）

```MYSQL
select 
	min(id),
	name,
	cardNo 
from 
	student2
group by
	name,cardNo
having 
	count(*)>=1;
	
-- 	查询不重复数据的所有字段信息
select 
	a.*
from 
	student2 a
where 
 	a.id
in	(
		select min(id) 
		from student2
		group by name,cardNo
		having count(*)>=1
	)
```

6）将过滤掉重复学生的信息导出到新表中stuent2_new

```mysql
create table stuent2_new
select 
	a.*
from 
	student2 a
where 
 	a.id
in	(
		select min(id) 
		from student2
		group by name,cardNo
		having count(*)>=1
	)
	
select * from stuent2_new;
```

7）从student2表中删除掉重复学生的信息（真正实现student2表中的重复数据的清洗工作）

```mysql
delete 
from 
	student2 
where 
	id 
not in	(
		select 
			t.`id`
		from (
				select min(id) as `id`
				from student2 
				group by name,cardNo 
				having count(*)>=1 
			)t
		)
	
select * from student2;+
-- 将子查询结果作为临时虚拟表t，才能进行删除操作，可参考3）的错误做法
```

## 6、常见函数

### 数学函数

```MYSQL
ABS(x)：返回x的绝对值
Ceil(x),CEILIN(x)：返回不小于x的最小整数值
Floor(x)：返回不大于x的最大整数值
Truncate(x,y)：返回数值x保留到小数点后y位的值
Round(x)：返回离x最近的整数
Round(x,y)：返回数值x保留到小数点后y位的值,但要四舍五入
Rand()：返回0~1的随机数
Rand(x)：返回0~1的随机数,x值相同 时返回随机数相同

Sign(x)：返回参数作为-1,0或1的符号，该符号取决于x的值为负、零或正
Pi()：返回∏的值，默认的显示小数位数是7位
Pow(x,y),power(x,y)：返回x的y乘方的结果值
Sqrt(x)：返回非负数x的二次方根
Exp(x)：返回e的x乘方后的值
Mod(x,y)：返回x除以y以后的余数
Log(x)：返回x的基数为2的对数
Log10(x)：返回x的基数为10的对数
Radians(x)：将角度转换为弧
Degrees(x)：返回参数x,该参数由弧度被转化为
Sin(x)：返回x正弦，其中x在弧度中被给定
Asin(x)：返回x的反正弦，即正弦为x的值
Cos(x)：返回x的余弦，其中x在弧度中被给定
Acos(x)：返回x的反余弦，即余弦为x的值
Tan(x)：返回x的反正切,正切为x的值
Cot(x)：返回(x):返回x的余切
```

### 字符串函数

1）字符串函数处理的结果仍为字符串函数

2）注意用字符串函数处理的数值结果进行排序和比较时，要转换为数值类型，否则结果有可能出错

```MYSQL
Char_length(s)：返回字符串s的字符数
Length(s)：返回值为字符串s的长度,单位为字节
Concat(s1,s2,…)：返回结果为连接参数产生的字符串
Insert(s1,x,len,s2)：将字符串s2替换s1的x位置开始长度为len的字符串
Upper(s),ucase(s)：将字符串s的所有字母都变成大写字母
Lower(s),lcase(s)：将字符串s的所有字母都变成小写字母
Left(s,n)：从字符串s开始的前n个字符
Right(s,n)：从字符串s开始，返回右边的n个字符
Ltrim(s)：返回字符串s,其引导空格字符被删除
Rtrim(s)：返回字符串s,结尾空格字符被删除
Trim(s)：去掉字符串s开始处和结尾处的空格
Trim(s1 from s)：去掉字符串s中开始处和结尾处的字符串s1
Substring(s,n,len)：获取从字符串s中的第n个位置开始长度为len的字符串
Instr(s,s1)：从字符串s中获取s1的开始位置

Lpad(s1,len,s2)：返回字符串s1,其左边由字符串s2填补到len字符长度，假如s1的长度大于len,则返回值被缩短至len字符
Rpad(s1,len,s2)：返回字符串s1,其右边由字符串s2填补到len字符长度，假如s1的长度大于len,则返回值被缩短至len字符
Repeat(s,n)：将字符串s重复n次
Space(n)：返回n个空格
Replace(s,s1,s2)：用字符串s2替代字符串s中的字符串s1
Strcmp(s1,s2)：比较字符串s1和s2
Locate(s1,s),position(s1 in s)：从字符串s中获取s1的开始位置
Reverse(s)：将字符串s的顺序反过来
Elt(n,s1,s2,…)：返回第n个字符串
```

### 其他函数

#### IF判断函数

​	IF(expr,V1,V2)：如果expr的值为true，则返回V1的值，如果expr的值为false，则返回V2的值。就是一个简单的三目表达式。

#### IFNULL选择函数

IFNULL(v1,v2)：如果v1不为空，则显示v1的值，否则显示v2的值

#### Md5加密函数

Md5(str)：对字符串str进行加密。经常用于对普通数据进行加密

```mysql
select md5('123456') as result;
-- e10adc3949ba59abbe56e057f20f883e
```

#### Cast() 、Convert() 类型转换函数

​	CAST(xxx AS 类型) , CONVERT(xxx,类型) 

```mysql
select cast('100' as SIGNED )+100  as result;  -- 200
select convert('100', SIGNED )+100  as result;  -- 200

-- mysql中会自动将字符串类型的数值进行转换成整数类型
select 100+100 as result;  -- 200
select '100'+100 as result;   -- 200
```

类型分类

> 整数 : SIGNED
> 无符号整数 : UNSIGNED
> 二进制，同带binary前缀的效果 : BINARY 
> 字符型，可带参数 : CHAR() 
> 日期 : DATE
> 时间: TIME
> 日期时间型 : DATETIME
> 浮点数 : DECIMAL

#### Format(x,n)格式函数

​	将数字x进行格式化，将x保留到小数点后n位，返回的还是字符串类型

```mysql
-- 会四舍五入操作，会使用千位符分割数据
select format(10000.14689,2)   -- 10,000.15 
```

##### 综合案例1

​	将员工表中的目前薪资进行format格式化操作，将目前薪资类型转换成浮点数，查看员工的姓名和目前薪资

```mysql
-- 方式1：
select
	姓名,
	format(convert(目前薪资,decimal),2)  as `工资`
from
	员工
order by
	`工资` desc

-- 方式2：推荐使用
select
	姓名,
	format(目前薪资,2)  as `工资`  -- 查看使用格式化
from
	员工
order by
	cast(目前薪资 as decimal) desc  -- 排序使用数值类型
```

##### 综合案例2

​	求每个部门的平均薪资后进行由高到低进行排序操作（发现问题，解决问题）

​	——注意 对比 format(x,y) 与 round(x,y)的不同

构建testFunc表，并添加数据

```mysql
create table testFunc(
  id int not null primary key auto_increment,
	name varchar(20),
	dept varchar(20),
	age int,
	salary varchar(20)
);

insert into testFunc(name,dept,age,salary)
values('a','管理部',18,1901),('b','管理部',17,90),('c','IT部',20,1800),('d','IT部',21,1800),('e','行政部',18,200),('f','行政部',22,3000);
```

**需求1：**求每个部门的平均薪资

```mysql
select
	dept,
	avg(salary) as `平均薪资`	
from 
	testfunc
group by
	dept
```

**需求2：**如果想 avg_salary取整，并按部门平均工资进行从大到小排序

```mysql
select
	dept,
	round(avg(salary),0)  as `平均薪资`	
from 
	testfunc
group by
	dept
order by 
	`平均薪资` desc
```

**需求3：**如果使用format函数取整，并按部门平均工资进行从大到小排序

```mysql
-- 错误写法
select
	dept,
	format(avg(salary),0)  as `平均薪资`	
from 
	testfunc
group by
	dept
order by 
	`平均薪资` desc	
-- 问题的原因：因为format函数转换后的数据依然是字符串类型，字符串和数值排序的规则是完全不一样，字符串是按照字典顺序，数值是按照大小

-- 解决方式1：
select
	dept,
	format(avg(salary),0)  as `平均薪资`	
from 
	testfunc
group by
	dept
order by 
	avg(salary) desc
	
-- 解决方式2：	
select
	dept,
	format(avg(salary),0)  as `平均薪资`	
from 
	testfunc
group by
	dept
order by 
	convert(avg(salary),decimal) desc
```

**需求4：**如果求每个部门的最高工资与最低工资

```mysql
-- 错误写法
select
	dept,
	avg(salary) as `平均薪资`,
	convert(max(salary),decimal) as `最高薪资`,
	convert(min(salary),decimal) as `最低薪资`
from 
	testfunc
group by
	dept
order by 
	`平均薪资` desc;
-- 是因为max函数和min函数使用的时机不对，我们应该向将字符串类型转换为数值类型后再进行求最值，而不是先求最值再转数值类型

-- 正确写法
select
	dept,
	round(avg(salary),0) as `平均薪资`,
	max(convert(salary,decimal)) as `最高薪资`,
	min(convert(salary,decimal)) as `最低薪资`
from 
	testfunc
group by
	dept
order by 
	`平均薪资` desc;
```

### 字符串拆分、拼接函数

####  substring_index函数（数据分列）

substring_index(str,delim,count)——str：要处理的字符串、delim：分隔符、count：计数

> 如果count是正数，那么就是从左往右数，第N个分隔符的左边的全部内容。 
> 相反，如果是负数，那么就是从右边开始数，第N个分隔符右边的所有内容。
> 不管向左还是向右，我们都是用的count的绝对值！

##### 综合案例3

构建student表，并添加数据

```mysql
create table student(
    `sname` varchar(20),
    `birthday` varchar(20),
    `subject-score` varchar(20)
);

insert into student(sname,birthday,`subject-score`)
values('学生A','2008-10-1','语文-A'),('学生A','2008-10-01','数学-B'),('学生B','2008-09-01','语文-B'),('学生B','2008-09-01','数学-C'),('学生C','2010-09-20','语文-A'),('学生C','2010-09-20','数学-A'),('学生D','2008-02-01','语文-C'),('学生D','2008-02-01','数学-D');
```

**需求1：**查询使用substring_index()函数将表中subject-score列进行拆分显示

```mysql
select 
	sname,
	birthday,
	substring_index(`subject-score`,'-',1) as `subject`,
	substring_index(`subject-score`,'-',-1) as `score`
from
	student;
```

**需求2：**如何提取出student表中的birthday中的年、月、日？

```mysql
select 
	sname,
	substring_index(birthday,'-',1) as `year`,
	substring_index(substring_index(birthday,'-',2),'-',-1) as `月`,
	substring_index(birthday,'-',-1) as `日`,
	substring_index(`subject-score`,'-',1) as `subject`,
	substring_index(`subject-score`,'-',-1) as `score`
from
	student;
```

#### concat函数（数据拼装）

##### 1）concat() 函数

​	concat(str1,str2,…) ，如果有任何一个参数为NULL ，则返回值为 NULL。

##### 2）concat_ws()  函数

​	concat_ws(separator,str1,str2,…)，可以指定参数之间的分隔符。

​	如果分隔符为 NULL，则结果为 NULL。但会忽略任何分隔符参数后的 NULL 值。

```mysql
select concat_ws('-',2008,10,1);	-- 2008-10-1  
select concat_ws(null,2008,10,1);	-- NULL 
select concat_ws('-',null,10,1);	-- 10-1 
```

##### 3）group_concat() 函数

功能：将group by产生的同一个分组中的值连接起来，返回一个字符串结果。

语法：group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] separator '分隔符')

说明：通过使用distinct可以排除重复值；如果希望对结果中的值进行排序，可以使用order by子句；separator是一个字符串值，缺省为一个逗号。

```mysql
select 
	sname,
	group_concat(`subject-score`) as `result` 
from 
	student
group by
	sname;
```

![1684990352404](C:\Users\6868668\AppData\Local\Temp\1684990352404.png)

## 7、窗口函数

### 窗口函数简介

> 1、窗口函数与分组聚合函数类似，例如SUM()，COUNT()，MAX()。
> ——它不会对结果进行分组。能使得输出中的行数与输入中的行数相同。
> 2、理解为记录的集合，就是在满足某种条件的记录集合上执行的特殊函数
> 3、对于每一条记录都要在此窗口内执行函数，有的函数随着记录的不同，窗口的大小都是固定，这种属于静态窗口。但是有的函数，不同的记录对应着不同的窗口，这种动态变化的窗口叫做滑动窗口。
> 4、在MySQL中使用OVER关键字代表窗口的意思。
> 5、窗口函数是对where或者group by子句处理后的结果再进行二次操作，因此会按照SQL语句的运行顺序，窗口函数一般放在select子句中（from前）

通常，我们使用窗口函数是为了解决在组内的排名问题和求前几topN的问题。

### 窗口函数剖析（语法角度）

```mysql
-- 1、简单的窗口函数语法（静态窗口）
select sum() over(partition by 字段 order by 字段) from tableName 
1. 聚合功能：在上述例子中，我们用了SUM()，但是你也可以用COUNT(), AVG()之类的计算功能

2. partition by：你只需将它看成GROUP BY子句，但是在窗口函数中，你要写partition by

3. order by：order by和普通查询语句中的order by没什么不同。注意，输出的顺序要仔细考虑

-- 2、复杂的窗口函数语法（滑动窗口）
select 函数名([参数]) over(partition by [分组字段] order by [排序字段] asc/desc rows/range between 起始位置 and 结束位置)

-- 窗口函数的解读：
-- 一般情况下窗口函数分为两个部分，第一个部分就是窗口函数的名称（也包含普通的聚合函数），在MySQL中有11种窗口函数提供给我们使用（rank(),lag(),lead()...），根据函数的性质，有的窗口函数需要参数，有的则不需要。

-- 第二部分是over修饰的窗口部分，在MySQL只能使用over关键字进行修饰窗口，代表着整个窗口的意思。over中有三个参数，这三个参数都是非必要的，根据实际情况来进行判定
-- 1、第一个参数：partition by [字段]，将数据根据此字段进行分成多份，如果不加partition by [字段]的话，它会把整个数据集当作一个窗口来看待，你可以认为它是在当前窗口中进行group by操作，但是不能写成group by，而且还要进行该窗口每一行记录都会执行。
-- 2、第二个参数：order by [排序字段] asc/desc，代表窗口内数据要不要进行排序操作，over中的order by不仅能起到窗口内进行排序操作，还起到窗口内从当前行到之前所有行的聚合功能（说明在over前面用的肯定是聚合函数（sum(),avg()等）而非窗口函数，如果over前面是具体的窗口函数就没有窗口内从当前行到之前所有行的聚合功能了）
-- 3、第三个参数：rows/range between 起始位置 and 结束位置，这个参数仅仅针对滑动窗口，所谓的滑动窗口就是在大的窗口中再分出小的窗口，小窗口也有开始位置和结束的位置。

1）rows：基于行，range：基于值得大小，表示行范围得意思
2）current row：边界时当前行
3）unbounded preceding：边界是分区中的第一行
4）unbounded following：边界是分区中的最后一行
5）expr preceding：边界是当前行减去expr的值
6）expr following：边界是当前行加上expr的值
```

### 理解示例

数据表

![1684991460523](C:\Users\6868668\AppData\Local\Temp\1684991460523.png)

想要的结果：性别获取平均GPA

![1684991503348](C:\Users\6868668\AppData\Local\Temp\1684991503348.png)

数据源

```mysql
create table students
(
   name varchar(20),
	 age int,
	 gender varchar(20),
	 gpa float
);

insert into students values('zhang',23,'男',3.9);
insert into students values('lishi',27,'女',3.5);
insert into students values('wang',30,'男',4.0);
insert into students values('zhao',22,'女',3.2);
insert into students values('tom',24,'男',3.0);
insert into students values('jack',29,'男',3.4);
```

#### 1）不使用窗口函数完成

```mysql
-- 1）常规聚合
select 
	gender,
	round(avg(gpa),1) as `gpa_avg`
from 
	students
group by
	gender
	
-- 2）连表查询
select 
	a.*,
	b.`gpa_avg`
from (
		select *
		from students 
	)a
inner join
	(
		select gender,	round(avg(gpa),1) as `gpa_avg`
		from students
		group by gender
	)b
on 
	b.gender=a.gender
```

#### 2）使用窗口函数完成

```mysql
select 
	*,
	round(avg(gpa) over(partition by gender),1) as `gpa_avg`
from 
	students;
-- 按性别对数据进行划分，并计算每种性别的平均GPA。然后，它将创建一个称为avg_gpa的新列，并为每行附加关联的平均GPA。
```

### 窗口函数优点

1）简单

​	与使用聚合函数然后合并结果相比，使用窗口函数仅需要多一行就可以获得所需要的结果。

2）快速

​	当你处理成百上千个千兆字节的数据时，这非常有用。

3）多功能性

​	窗口函数具有多种功能，比如，包括添加移动平均线，添加行号和滞后数据等等。

### 窗口函数解析

> 1、窗口函数是 SQL 中一类特别的函数。和聚合函数相似，窗口函数的输入也是多行记录。
> 2、不同的是，聚合函数作用于由 GROUP BY 子句聚合的组，而窗口函数则作用于一个窗口。这里，窗口是由一个 OVER 子句 定义的多行记录。
> 3、聚合函数对其所作用的每一组记录输出一条结果，而窗口函数对其所作用的窗口中的每一行记录输出一条结果。一些聚合函数，如 sum, max, min, avg,count 等也可以当作窗口函数使用。
> 4、与聚集函数一样，窗口函数也针对定义的行集（组）执行聚集，但它不像聚集函数那样每组之返回一个值，窗口函数可以为每组返回多个值。
> 5、实际上，DB2中称这种函数为**联机分析处理OLAP函数**，而Oracle把它们称为**解析函数**，但ISO SQL标准把它们称为窗口函数。窗口函数一般在OLAP分析、制作报表过程中会使用到。

### 窗口函数功能

分类

> 序号函数：ROW_NUMBER()、RANK()、DENSE_RANK()
> 分布函数：PERCENT_RANK()、CUME_DIST()
> 前后函数：LAG()、LEAD()
> 头尾函数：FIRST_VALUE()、LAST_VALUE()
> 其他函数：NTH_VALUE()、NTILE()
> 聚合函数：SUM(),AVG(),MIN(),MAX(),COUNT()

![1684995437393](C:\Users\6868668\AppData\Local\Temp\1684995437393.png)

### 窗口函数语法

![1684996533784](C:\Users\6868668\AppData\Local\Temp\1684996533784.png)

基于行的合法范围

```mysql
rows BETWEEN 1 PRECEDING AND 1 FOLLOWING 窗口范围是当前行、前一行、后一行一共三行记录
rows  UNBOUNDED FOLLOWING 窗口范围是当前行到分区中的最后一行
rows BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING 窗口范围是当前分区中所有行，等同于不写
```

基于范围

​	和基于行类似，但有些范围不是直接可以用行数来表示的

```mysql
INTERVAL 7 DAY PRECEDING 窗口范围是一周前的订单开始，截止到当前行
RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW 默认框架
```

### 窗口函数示例

#### 订单购买案例

##### 数据源

构建business表，并添加数据

```mysql
create table business(
	name varchar(50),
	orderdate varchar(50),
	cost int
); 

INSERT INTO `business` VALUES ('jack', '2017-01-01', 10);
INSERT INTO `business` VALUES ('tony', '2017-01-02', 15);
INSERT INTO `business` VALUES ('jack', '2017-02-03', 23);
INSERT INTO `business` VALUES ('tony', '2017-01-04', 29);
INSERT INTO `business` VALUES ('jack', '2017-01-05', 46);
INSERT INTO `business` VALUES ('jack', '2017-04-06', 42);
INSERT INTO `business` VALUES ('tony', '2017-01-07', 50);
INSERT INTO `business` VALUES ('jack', '2017-01-08', 55);
INSERT INTO `business` VALUES ('mart', '2017-04-08', 62);
INSERT INTO `business` VALUES ('mart', '2017-04-09', 68);
INSERT INTO `business` VALUES ('neil', '2017-05-10', 12);
INSERT INTO `business` VALUES ('mart', '2017-04-11', 75);
INSERT INTO `business` VALUES ('neil', '2017-06-12', 80);
INSERT INTO `business` VALUES ('mart', '2017-04-13', 94);
```

##### 需求

###### （1）查询在 2017 年 4 月份购买过的顾客及总人数

```mysql
-- 错误写法(求的是每个人的总次数)
select
	name,
	count(*) as cnt
from
	business
where
	substring(orderdate,1,7)='2017-04'
group by
	name;
	
-- 正确写法（求的是总人数，添加在每个人的后面）
select
	name,
	count(*) over() as `cnt`
from 
	business
where 
	year(orderdate)=2017 and month(orderdate)=4
group by
	name;
```

![1685001601400](C:\Users\6868668\AppData\Local\Temp\1685001601400.png)

###### （2）查询顾客的购买明细及月购买总额

```mysql
select 
	*,
	sum(cost) over(partition by year(orderdate),month(orderdate)) as `月购买总金额`
from 
	business
order by
	orderdate; 
```

![1685001614974](C:\Users\6868668\AppData\Local\Temp\1685001614974.png)

###### （3）将每个顾客的 cost 按照日期进行累加

![1685003603508](C:\Users\6868668\AppData\Local\Temp\1685003603508.png)

​	rows 必须跟在 order by 子句之后，对排序的结果进行限制，使用固定的行数来限制分区中的数据行数量

```mysql
select
	*,	
	-- 1、范围：整个窗口中所有的行，将cost进行累加
	sum(cost) over() as `sample1`,
	
	-- 2、范围：整个窗口中的所有行，按照name进行分组，组内进行相加求和，求每个顾客的cost总金额
	sum(cost) over(partition by name) as `sample12`,
	
	-- 3、范围：整个窗口中的所有行，按照name进行分组，组内进行相加，求当前行和之前所有行的聚合求和
	-- over中使用order by排序特点：不仅起到窗口内进行排序的功能，还起到窗口内聚合的功能（当前行和之前所有行的聚合），前提是over前面必须是聚合函数
	sum(cost) over(partition by name order by orderdate) as `sample13`,
	
	-- 4、范围：滑动窗口，整个窗口中小窗口，按照name进行分组，组内进行相加，求当前行和之前所有行的聚合求和，和sample3一样效果
	sum(cost) over(partition by name order by orderdate rows between unbounded preceding and current row ) as `sample14`,

	-- 5、范围：滑动窗口，整个窗口中小窗口，按照name进行分组，组内进行相加，求当前行和之后所有行的聚合求和
	sum(cost) over(partition by name order by orderdate rows between current row  and unbounded following ) as `sample15`,
	
	-- 6、范围：滑动窗口，整个窗口中小窗口，按照name进行分组，组内进行相加，求当前行和前面一行进行聚合 
	sum(cost) over(partition by name order by orderdate rows between 1 preceding and current row ) as `sample16`,
	
	-- 7、范围：滑动窗口，整个窗口中小窗口，按照name进行分组，组内进行相加，求当前行和后面一行进行聚合 
	sum(cost) over(partition by name order by orderdate rows between current row and 1 following ) as `sample17`,
	
	-- 8、范围：滑动窗口，整个窗口中小窗口，按照name进行分组，组内进行相加，求当前行和前一行以及后面一行进行聚合
	-- 不用写当前行，默认情况就是当前行，只需要写前一行和后一行即可
	sum(cost) over(partition by name order by orderdate rows between 1 preceding and 1 following) as `sample18`
from 
	business
```

###### （4）查询每个顾客上次的购买时间

​	不使用窗口函数完成

![1685003944802](C:\Users\6868668\AppData\Local\Temp\1685003944802.png)

```mysql
select 
	a.*,
	(
		select max(b.orderdate)
		from business b 
		where a.name =b.name and a.orderdate >b.orderdate 
	) as `上一次购买的日期`
from 
	business a
order by
	a.name,a.orderdate
```

​	使用窗口函数完成一（推荐使用）

![1685004410682](C:\Users\6868668\AppData\Local\Temp\1685004410682.png)

```mysql
select
	*,
	lag(orderdate,1,'无') over(partition by name order by orderdate) as `上一次购买的日期`,
	lead(orderdate,1,'无') over(partition by name order by orderdate) as `下一次购买的日期`
from 
	business;
```

​	使用窗口函数完成二

![1685004547883](C:\Users\6868668\AppData\Local\Temp\1685004547883.png)

```mysql
select
	*,
	-- 当前行和前一行聚合，求最小的那个就是上一次购买时间
	min(orderdate) over(partition by name order by orderdate rows between 1 preceding and current row) as `上一次购买的日期`,
	max(orderdate) over(partition by name order by orderdate rows between current row and 1 following) as `下一次购买的日期`
from 
	business
```

​	使用窗口函数完成三

![1685004684817](C:\Users\6868668\AppData\Local\Temp\1685004684817.png)

```mysql
select
	*,
	-- 当前行和前一行聚合，求最小的那个就是上一次购买时间
	first_value(orderdate) over(partition by name order by orderdate rows between 1 preceding and current row) as `上一次购买的日期`,
	last_value(orderdate) over(partition by name order by orderdate rows between current row and 1 following) as `下一次购买的日期`
from 
	business
```

###### （5）查询前20%时间的订单信息

![1685004958659](C:\Users\6868668\AppData\Local\Temp\1685004958659.png)

```mysql
select
	t.name,
	t.orderdate,
	t.cost 
from(
    	-- 将数据平均分成5成
		select
			name,orderdate,cost,
			ntile(5) over(order by month(orderdate)) as `等级`
		from business
	)t
where 
	t.`等级`=1;
```

#### 排名实现案例

##### 函数说明

> RANK() ：排序相同时会重复，总数不会变（比如：1，1，3）
> DENSE_RANK() ：排序相同时会重复，总数会减少（比如：1，1，2）
> ROW_NUMBER() ：会根据顺序计算（比如：1，2，3，4......）

##### 数据源

构建score表，并添加数据

```mysql
create table score(
	name varchar(20),
	subject varchar(20),
	score int
);

INSERT INTO `score` VALUES ('AA', 'chinese', 87);
INSERT INTO `score` VALUES ('AA', 'math', 95);
INSERT INTO `score` VALUES ('AA', 'english', 68);
INSERT INTO `score` VALUES ('BB', 'chinese', 94);
INSERT INTO `score` VALUES ('BB', 'math', 56);
INSERT INTO `score` VALUES ('BB', 'english', 84);
INSERT INTO `score` VALUES ('CC', 'chinese', 64);
INSERT INTO `score` VALUES ('CC', 'math', 86);
INSERT INTO `score` VALUES ('CC', 'english', 84);
INSERT INTO `score` VALUES ('DD ', 'chinese', 65);
INSERT INTO `score` VALUES ('DD', 'math', 85);
INSERT INTO `score` VALUES ('DD', 'english', 78);
```

##### 需求

​	数据库不支持窗口函数，或版本较低，怎么办？

###### （1）计算每门学科成绩排名

![1685005808254](C:\Users\6868668\AppData\Local\Temp\1685005808254.png)

```mysql
select 
	*,
	rank() over(partition by subject order by score desc) as `rank名次`,
	dense_rank() over(partition by subject order by score desc) as `dense_rank名次`,
	row_number() over(partition by subject order by score desc) as `row_number名次`
from 
	score;
```

常规写法

```mysql
-- 先给subject进行排序
select 
	a.*,
	(
		select count(b.score)
		from score b
		where a.subject =b.subject and a.score <b.score 
	)+1 as `排名`
from 
	score a
order by
	a.subject,`排名`
```

###### （2）找出每门学科的前三名

![1685005928107](C:\Users\6868668\AppData\Local\Temp\1685005928107.png)

```mysql
select
	t.*
from (
		select *,	dense_rank() over(partition by subject order by score desc) as `dense_rank名次`
		from score	
	)t	
where 
	t.`dense_rank名次`<=3;
```

常规写法

```mysql
-- 方式一
select 
	t.*
from
	(select a.*,
		(
			select count(b.score)
			from score b
			where a.subject =b.subject and a.score <b.score 
		)+1 as `排名`
	from score a
	order by a.subject,`排名`	
	)t
where 
	t.`排名`<=3;
	
-- 方式二
select 
	t.*
from
	(select a.*,
		(
			select count(distinct b.score)
			from score b
			where a.subject =b.subject and a.score <b.score 
		)+1 as `排名`
	from score a
	order by a.subject,`排名`	
	)t
where 
	t.`排名`<=3;
```

###### （3）计算每个学生各科学科的总分，并进行总分的排名

![1685006615627](C:\Users\6868668\AppData\Local\Temp\1685006615627.png)

```mysql
select 
	name,
	sum(if(subject='chinese',score,0)) as `语文`,
	sum(if(subject='math',score,0)) as `数学`,
	sum(if(subject='english',score,0)) as `英文`,
	sum(score) as `三门总分`,
	dense_rank() over(order by sum(score) desc) as `名次`
from 
	score
group by
	name;
```

常规写法

```mysql
select 	t1.*,
	(
		select count(distinct t2.`三门总分`)
		from(
				select 
					name,
					sum(if(subject='chinese',score,0)) as `语文`,
					sum(if(subject='math',score,0)) as `数学`,
					sum(if(subject='english',score,0)) as `英文`,
					sum(score) as `三门总分`
				from score
				group by name 
			)t2	
		where t1.`三门总分`<t2.`三门总分`
	)+1 as `名次`
from(
		select 
			name,
			sum(if(subject='chinese',score,0)) as `语文`,
			sum(if(subject='math',score,0)) as `数学`,
			sum(if(subject='english',score,0)) as `英文`,
			sum(score) as `三门总分`
		from score
		group by name
	)t1;
```

## 【课件待补充】

视频：MYSQL进阶07、08、09、10对应的文件都缺了，只能边听边写

面试真题课后训练的.md

![1685007869804](C:\Users\6868668\AppData\Local\Temp\1685007869804.png)

MYSQL函数及其实战应用 02.md

![1685008021486](C:\Users\6868668\AppData\Local\Temp\1685008021486.png)

MYSQL企业面试题精讲3.md

![1685008184492](C:\Users\6868668\AppData\Local\Temp\1685008184492.png)

企业面试：用户留存率问题.md

![1685008451773](C:\Users\6868668\AppData\Local\Temp\1685008451773.png)

==MYSQL进阶结束后，先进行fine BI + Report，再进行MYSQL+BI项目==

# 六、fine BI + Report











